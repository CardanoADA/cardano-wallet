-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet
@version 2.0.0


-- | Decoder for the rust-cardano packfile format.
--   
--   A pack file is a collection of bytestring blobs.
--   
--   The reference implementation is in <a>packfile.rs</a>.
module Cardano.Wallet.Binary.Packfile

-- | Decode a Cardano version 1 pack file. The blobs are returned as a
--   list. Decoding is not incremental, and all data is stored in memory.
decodePackfile :: ByteString -> Either PackfileError [ByteString]

-- | Things related to the file format that can go wrong when decoding a
--   pack file.
data PackfileError
MissingMagicError :: PackfileError
WrongFileTypeError :: PackfileError
VersionTooOldError :: PackfileError
VersionTooNewError :: PackfileError
BlobDecodeError :: String -> PackfileError
instance GHC.Classes.Eq Cardano.Wallet.Binary.Packfile.PackfileError
instance GHC.Show.Show Cardano.Wallet.Binary.Packfile.PackfileError


-- | This module provides mnemonic (backup phrase) creation, and conversion
--   of a mnemonic to seed for wallet restoration.
module Cardano.Wallet.Mnemonic

-- | A backup-phrase in the form of a non-empty of Mnemonic words
--   Constructor isn't exposed.
data Mnemonic (mw :: Nat)
data Entropy (n :: Nat)
type family EntropySize (n :: Nat) :: Nat
type family MnemonicWords (n :: Nat) :: Nat

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MnemonicError csz

-- | This wraps EntropyError of <a>Cardano.Encoding.BIP39</a>
newtype MnemonicException csz

-- | Invalid entropy length or checksum
UnexpectedEntropyError :: EntropyError csz -> MnemonicException csz
data EntropyError (csz :: Nat)
ErrInvalidEntropyLength :: Int -> Int -> EntropyError
ErrInvalidEntropyChecksum :: Checksum csz -> Checksum csz -> EntropyError
data DictionaryError
ErrInvalidDictionaryWord :: String -> DictionaryError
data MnemonicWordsError
ErrWrongNumberOfWords :: Int -> Int -> MnemonicWordsError

-- | Smart-constructor for the Entropy
mkEntropy :: forall n csz. (ValidEntropySize n, ValidChecksumSize n csz) => ByteString -> Either (EntropyError csz) (Entropy n)

-- | Smart-constructor for the Mnemonic
mkMnemonic :: forall mw n csz. (ConsistentEntropy n mw csz, EntropySize mw ~ n) => [Text] -> Either (MnemonicError csz) (Mnemonic mw)

-- | Generate Entropy of a given size using a random seed.
--   
--   Example: do ent &lt;- genEntropy :: IO (Entropy 12)
genEntropy :: forall n csz. (ValidEntropySize n, ValidChecksumSize n csz) => IO (Entropy n)
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Convert an Entropy to a corresponding Mnemonic Sentence
entropyToMnemonic :: forall mw n csz. (ValidMnemonicSentence mw, ValidEntropySize n, ValidChecksumSize n csz, n ~ EntropySize mw, mw ~ MnemonicWords n) => Entropy n -> Mnemonic mw

-- | Convert <a>Entropy</a> to a raw <a>ByteString</a>
entropyToBytes :: Entropy n -> ScrubbedBytes
ambiguousNatVal :: forall n. KnownNat n => Integer
mnemonicToText :: Mnemonic mw -> [Text]
instance GHC.Show.Show (Cardano.Wallet.Mnemonic.MnemonicError csz)
instance GHC.Classes.Eq (Cardano.Wallet.Mnemonic.MnemonicError csz)
instance GHC.Show.Show (Cardano.Wallet.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Wallet.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Wallet.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Wallet.Mnemonic.MnemonicException csz)


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive
data Block
Block :: !BlockHeader -> !Set Tx -> Block
[header] :: Block -> !BlockHeader
[transactions] :: Block -> !Set Tx
data BlockHeader
BlockHeader :: SlotId -> !Hash "BlockHeader" -> BlockHeader
[slotId] :: BlockHeader -> SlotId
[prevBlockHash] :: BlockHeader -> !Hash "BlockHeader"
data Tx
Tx :: ![TxIn] -> ![TxOut] -> Tx

-- | Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[inputs] :: Tx -> ![TxIn]

-- | Order of outputs matter in the transaction representations. Outputs
--   are used as inputs for next transactions which refer to them using
--   their indexes. It matters also for serialization.
[outputs] :: Tx -> ![TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[inputId] :: TxIn -> !Hash "Tx"
[inputIx] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[address] :: TxOut -> !Address
[coin] :: TxOut -> !Coin
txIns :: Set Tx -> Set TxIn
updatePending :: Block -> Set Tx -> Set Tx
newtype Address
Address :: ByteString -> Address
[getAddress] :: Address -> ByteString

-- | This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   - A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address scheme.
--   
--   <ul>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s
isOurs :: IsOurs s => Address -> s -> (Bool, s)

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[getCoin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[getUTxO] :: UTxO -> Map TxIn TxOut
balance :: UTxO -> Integer
excluding :: UTxO -> Set TxIn -> UTxO
isSubsetOf :: UTxO -> UTxO -> Bool
restrictedBy :: UTxO -> Set TxIn -> UTxO
restrictedTo :: UTxO -> Set TxOut -> UTxO
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !Word64 -> !Word16 -> SlotId
[epochIndex] :: SlotId -> !Word64
[slotNumber] :: SlotId -> !Word16

-- | Whether the epoch index and slot number are in range.
isValidSlotId :: SlotId -> Bool

-- | Hard-coded for the time being
slotsPerEpoch :: Word64

-- | <tt>slotDiff a b</tt> is the number of slots by which <tt>a</tt> is
--   greater than <tt>b</tt>.
slotDiff :: SlotId -> SlotId -> Integer

-- | Add a number of slots to an (Epoch, LocalSlotIndex) pair, where the
--   number of slots can be greater than one epoch.
slotIncr :: Word64 -> SlotId -> SlotId
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[getHash] :: Hash -> ByteString

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a

-- | Check whether an invariants holds or not.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: String -> a -> (a -> Bool) -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Block
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Block
instance GHC.Generics.Generic Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Tx
instance GHC.Base.Monoid Cardano.Wallet.Primitive.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Address
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Primitive.ShowFmt a)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Block
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Tx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.UTxO
instance Cardano.Wallet.Primitive.Dom Cardano.Wallet.Primitive.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.TxIn
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.TxIn, Cardano.Wallet.Primitive.TxOut)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Hash tag)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.SlotId
instance GHC.Enum.Enum Cardano.Wallet.Primitive.SlotId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Coin
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Address
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Address


-- | These are (partial) CBOR decoders for blocks and block headers. Note
--   that we ignore most of the block's and header's content and only
--   retrieve the pieces of information relevant to us, wallet (we do
--   assume a trusted node and therefore, we needn't to care about
--   verifying signatures and blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Wallet.Binary
decodeBlock :: Decoder s Block
decodeBlockHeader :: Decoder s BlockHeader
decodeTx :: Decoder s Tx
encodeTx :: Tx -> Encoding

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> Encoding -> Encoding

-- | Compute a transaction id; assumed to be effectively injective. It
--   returns an hex-encoded 64-byte hash.
--   
--   NOTE: This is a rather expensive operation
txId :: Tx -> Hash "Tx"

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]


-- | Primitives for performing address derivation for some given schemes.
--   This is where most of the crypto happens in the wallet and, it is
--   quite important to ensure that the following implementation matches
--   with other wallet softwares (like Yoroi/Icarus or the cardano-cli)
module Cardano.Wallet.AddressDerivation

-- | A cryptographic key, with phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Key 'RootK XPrv
--   let accountPubKey = Key 'AccountK XPub
--   let addressPubKey = Key 'AddressK XPub
--   </pre>
data Key (level :: Depth) key

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
data Index (derivationType :: DerivationType) (level :: Depth)
getIndex :: Index derivationType level -> Word32

-- | Type of derivation that should be used with the given indexes.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
newtype Passphrase (goal :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase

-- | Extract the public key part of a private key.
publicKey :: Key level XPrv -> Key level XPub
data XPub
data XPrv

-- | Marker for the change chain. In practice, change of a transaction goes
--   onto the addresses generated on the internal chain, whereas the
--   external chain is used for addresses that are part of the
--   <tt>advertised</tt> targets of a transaction
data ChangeChain
InternalChain :: ChangeChain
ExternalChain :: ChangeChain

-- | Generate a root key from a corresponding seed
generateKeyFromSeed :: (ScrubbedBytes, Passphrase "generation") -> Passphrase "encryption" -> Key  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (ScrubbedBytes, Passphrase "generation") -> Passphrase "encryption" -> Key depth XPrv

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> Key  'RootK XPrv -> Index  'Hardened  'AccountK -> Key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   It is preferred to use <a>deriveAddressPublicKey</a> whenever possible
--   to avoid having to manipulate passphrases and private keys.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> Key  'AccountK XPrv -> ChangeChain -> Index  'Soft  'AddressK -> Key  'AddressK XPrv

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: Key  'AccountK XPub -> ChangeChain -> Index  'Soft  'AddressK -> Key  'AddressK XPub

-- | Encode a public key to a (Byron / Legacy) Cardano <a>Address</a>. This
--   is mostly dubious CBOR serializations with no data attributes.
keyToAddress :: Key  'AddressK XPub -> Address
instance GHC.Classes.Eq Cardano.Wallet.AddressDerivation.ChangeChain
instance GHC.Show.Show Cardano.Wallet.AddressDerivation.ChangeChain
instance GHC.Generics.Generic Cardano.Wallet.AddressDerivation.ChangeChain
instance GHC.Base.Monoid (Cardano.Wallet.AddressDerivation.Passphrase goal)
instance GHC.Base.Semigroup (Cardano.Wallet.AddressDerivation.Passphrase goal)
instance GHC.Show.Show (Cardano.Wallet.AddressDerivation.Passphrase goal)
instance GHC.Classes.Ord (Cardano.Wallet.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Wallet.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Wallet.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Wallet.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.AddressDerivation.Key level key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.AddressDerivation.Key level key)
instance GHC.Generics.Generic (Cardano.Wallet.AddressDerivation.Key level key)
instance Control.DeepSeq.NFData Cardano.Wallet.AddressDerivation.ChangeChain
instance GHC.Enum.Enum Cardano.Wallet.AddressDerivation.ChangeChain
instance Control.DeepSeq.NFData (Cardano.Wallet.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Wallet.AddressDerivation.Index 'Cardano.Wallet.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Wallet.AddressDerivation.Index 'Cardano.Wallet.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.Wallet.AddressDerivation.Index 'Cardano.Wallet.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Wallet.AddressDerivation.Index 'Cardano.Wallet.AddressDerivation.Soft level)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.AddressDerivation.Key level key)


-- | This module contains primitives necessary to perform address
--   discovery. So far, we're only interested in address following a
--   sequential derivation scheme as specified in BIP-0044. Later, we may
--   introduce backward compatibility with random address scheme from the
--   legacy Cardano wallets.
module Cardano.Wallet.AddressDiscovery

-- | Maximum number of consecutive undiscovered addresses allowed
data AddressPoolGap

-- | Possible errors when casting to an <a>AddressPoolGap</a>
newtype MkAddressPoolGapError
ErrGapOutOfRange :: Word8 -> MkAddressPoolGapError

-- | A default <a>AddressPoolGap</a>, as suggested in BIP-0044
defaultAddressPoolGap :: AddressPoolGap

-- | Smart constructor for <a>AddressPoolGap</a>
mkAddressPoolGap :: Word8 -> Either MkAddressPoolGapError AddressPoolGap

-- | An <a>AddressPool</a> which keeps track of sequential addresses within
--   a given Account and change chain. See <a>mkAddressPool</a> to create a
--   new or existing pool:
--   
--   <pre>
--   &gt;&gt;&gt; mkAddressPool xpub gap changeChain mempty
--   AddressPool { }
--   </pre>
data AddressPool

-- | The actual gap for the pool. This can't change for a given pool.
gap :: AddressPool -> AddressPoolGap

-- | Get all addresses in the pool, sorted from the first address
--   discovered, up until the next one.
--   
--   In practice, we always have:
--   
--   <pre>
--   mkAddressPool key g cc (addresses pool) == pool
--   </pre>
addresses :: AddressPool -> [Address]

-- | Whether this pool tracks addrs on the internal or external chain
changeChain :: AddressPool -> ChangeChain

-- | Corresponding key for the pool (a pool is tied to only one account)
accountPubKey :: AddressPool -> Key  'AccountK XPub

-- | Create a new Address pool from a list of addresses. Note that, the
--   list is expected to be ordered in sequence (first indexes, first in
--   the list).
--   
--   The pool will grow from the start if less than <tt>g ::
--   AddressPoolGap</tt> are given, such that, there are always <tt>g</tt>
--   undiscovered addresses in the pool.
mkAddressPool :: Key  'AccountK XPub -> AddressPoolGap -> ChangeChain -> [Address] -> AddressPool

-- | Lookup an address in the pool. When we find an address in a pool, the
--   pool may be amended if the address was discovered near the edge. It is
--   also possible that the pool is not amended at all - this happens in
--   the case that an address is discovered <tt>far</tt> from the edge.
lookupAddress :: Address -> AddressPool -> (Maybe (Index  'Soft  'AddressK), AddressPool)
newtype SeqState
SeqState :: (AddressPool, AddressPool) -> SeqState
instance GHC.Base.Semigroup Cardano.Wallet.AddressDiscovery.SeqState
instance Control.DeepSeq.NFData Cardano.Wallet.AddressDiscovery.SeqState
instance GHC.Show.Show Cardano.Wallet.AddressDiscovery.SeqState
instance GHC.Generics.Generic Cardano.Wallet.AddressDiscovery.SeqState
instance GHC.Classes.Eq Cardano.Wallet.AddressDiscovery.AddressPool
instance GHC.Show.Show Cardano.Wallet.AddressDiscovery.AddressPool
instance GHC.Generics.Generic Cardano.Wallet.AddressDiscovery.AddressPool
instance GHC.Show.Show Cardano.Wallet.AddressDiscovery.MkAddressPoolGapError
instance GHC.Classes.Eq Cardano.Wallet.AddressDiscovery.MkAddressPoolGapError
instance GHC.Classes.Ord Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance GHC.Classes.Eq Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance GHC.Generics.Generic Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance Cardano.Wallet.Primitive.IsOurs Cardano.Wallet.AddressDiscovery.SeqState
instance Control.DeepSeq.NFData Cardano.Wallet.AddressDiscovery.AddressPool
instance GHC.Base.Semigroup Cardano.Wallet.AddressDiscovery.AddressPool
instance Control.DeepSeq.NFData Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance GHC.Enum.Bounded Cardano.Wallet.AddressDiscovery.AddressPoolGap
instance GHC.Enum.Enum Cardano.Wallet.AddressDiscovery.AddressPoolGap


-- | Here we find the "business logic" to manage a Cardano wallet. This is
--   a direct implementation of the model from the <a>Formal Specification
--   for a Cardano Wallet</a> Note that, this module is purposedly agnostic
--   to how blocks are retrieved or how various types are serialized.
--   
--   This is really about how the wallet keep track of its internal state,
--   and its UTxO (where the relationship is defined via the <a>IsOurs</a>
--   abstraction to allow this core code to be used with any sort of
--   derivation scheme).
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here :)
module Cardano.Wallet

-- | An opaque wallet type, see <tt>initWallet</tt> and <tt>applyBlock</tt>
--   to construct and update wallets.
--   
--   Internally, this keeps track or a few things including:
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Pending transaction</li>
--   <li>TODO: Transaction history</li>
--   <li>TODO: Known &amp; used addresses</li>
--   </ul>
data Wallet s

-- | Create an empty wallet from an initial state
initWallet :: (IsOurs s, Semigroup s, NFData s, Show s) => s -> Wallet s

-- | Get the wallet current tip
currentTip :: Wallet s -> SlotId

-- | Apply Block is the only way to make the wallet evolve.
applyBlock :: Block -> NonEmpty (Wallet s) -> NonEmpty (Wallet s)

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: Wallet s -> Integer

-- | Total balance = <a>balance</a> . <a>totalUTxO</a>
totalBalance :: Wallet s -> Integer

-- | Total UTxO = <a>availableUTxO</a> &lt;&gt; "pending UTxO"
totalUTxO :: Wallet s -> UTxO

-- | Available UTxO = UTxO that aren't part of pending txs
availableUTxO :: Wallet s -> UTxO

-- | Return all transaction outputs that are ours. This plays well within a
--   <a>State</a> monad.
--   
--   <pre>
--   myFunction :: Block -&gt; State s Result
--   myFunction b = do
--      ours &lt;- state $ txOutsOurs (transaction b)
--      return $ someComputation ours
--   </pre>
txOutsOurs :: forall s. IsOurs s => Set Tx -> s -> (Set TxOut, s)

-- | Construct a UTxO corresponding to a given transaction. It is important
--   for the transaction outputs to be ordered correctly, since they become
--   available inputs for the subsequent blocks.
utxoFromTx :: Tx -> UTxO
data WalletMetadata
WalletMetadata :: !WalletId -> !WalletName -> !AddressPoolGap -> !WalletPassphraseInfo -> !WalletStatus -> !WalletDelegation -> WalletMetadata
[id] :: WalletMetadata -> !WalletId
[name] :: WalletMetadata -> !WalletName
[addressPoolGap] :: WalletMetadata -> !AddressPoolGap
[passphraseInfo] :: WalletMetadata -> !WalletPassphraseInfo
[status] :: WalletMetadata -> !WalletStatus
[delegation] :: WalletMetadata -> !WalletDelegation
newtype WalletId
WalletId :: Text -> WalletId
newtype WalletName
WalletName :: Text -> WalletName
[getWalletName] :: WalletName -> Text
newtype WalletTimestamp
WalletTimestamp :: Microsecond -> WalletTimestamp
data WalletStatus
Ready :: WalletStatus
Restoring :: WalletStatus
data WalletDelegation
Delegated :: WalletDelegation
NotDelegated :: WalletDelegation
newtype WalletPassphraseInfo
WalletPassphraseInfo :: WalletTimestamp -> WalletPassphraseInfo
[lastUpdated] :: WalletPassphraseInfo -> WalletTimestamp
instance GHC.Generics.Generic Cardano.Wallet.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.WalletMetadata
instance GHC.Classes.Eq Cardano.Wallet.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.WalletPassphraseInfo
instance GHC.Show.Show Cardano.Wallet.WalletDelegation
instance GHC.Classes.Eq Cardano.Wallet.WalletDelegation
instance GHC.Show.Show Cardano.Wallet.WalletStatus
instance GHC.Classes.Eq Cardano.Wallet.WalletStatus
instance GHC.Show.Show Cardano.Wallet.WalletTimestamp
instance GHC.Classes.Ord Cardano.Wallet.WalletTimestamp
instance GHC.Classes.Eq Cardano.Wallet.WalletTimestamp
instance GHC.Show.Show Cardano.Wallet.WalletId
instance GHC.Classes.Ord Cardano.Wallet.WalletId
instance GHC.Classes.Eq Cardano.Wallet.WalletId
instance GHC.Show.Show Cardano.Wallet.WalletName
instance GHC.Classes.Eq Cardano.Wallet.WalletName
instance GHC.Show.Show (Cardano.Wallet.Wallet s)
instance Control.DeepSeq.NFData (Cardano.Wallet.Wallet s)


-- | Database / Pesistence layer for the wallet backend. This is where we
--   define the interface allowing us to store and fetch various data on
--   our wallets.
module Cardano.DBLayer

-- | A Database interface for storing various things in a DB. In practice,
--   we'll need some extra contraints on the wallet state that allows us to
--   serialize and unserialize it (e.g. <tt>forall s. (Serialize s) =&gt;
--   ...</tt>)
data DBLayer m s
DBLayer :: (PrimaryKey WalletId -> NonEmpty (Wallet s) -> m ()) -> (PrimaryKey WalletId -> m (Maybe (NonEmpty (Wallet s)))) -> m [PrimaryKey WalletId] -> DBLayer m s
[putCheckpoints] :: DBLayer m s -> PrimaryKey WalletId -> NonEmpty (Wallet s) -> m ()
[readCheckpoints] :: DBLayer m s -> PrimaryKey WalletId -> m (Maybe (NonEmpty (Wallet s)))
[readWallets] :: DBLayer m s -> m [PrimaryKey WalletId]

-- | A primary key which can take many forms depending on the value. This
--   may become a type family as we move forward, but for now, it
--   illustrate that some queries are ran against some sort of store;
--   
--   As a matter of fact, we may manipulate multiple wallets at the same
--   time, so, functions like <tt>enqueueCheckpoint</tt> needs to be
--   associated to a corresponding wallet. Some other may not because they
--   are information valid for all wallets (like for instance, the last
--   known network tip).
newtype PrimaryKey key
PrimaryKey :: key -> PrimaryKey key
instance GHC.Classes.Ord key => GHC.Classes.Ord (Cardano.DBLayer.PrimaryKey key)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.DBLayer.PrimaryKey key)


-- | Dummy implementation of the database-layer, using MVar. This may be
--   good for state-machine testing in order to compare it with an
--   implementation on a real data store.
module Cardano.DBLayer.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: forall s. IO (DBLayer IO s)

module Cardano.NetworkLayer
data NetworkLayer m e0 e1
NetworkLayer :: (SlotId -> ExceptT e0 m [Block]) -> ExceptT e1 m (Hash "BlockHeader", BlockHeader) -> NetworkLayer m e0 e1

-- | Gets some blocks from the node. It will not necessarily return all the
--   blocks that the node has, but will receive a reasonable-sized chunk.
--   It will never return blocks from before the given slot. It may return
--   an empty list if the node does not have any blocks from after the
--   starting slot.
[nextBlocks] :: NetworkLayer m e0 e1 -> SlotId -> ExceptT e0 m [Block]
[networkTip] :: NetworkLayer m e0 e1 -> ExceptT e1 m (Hash "BlockHeader", BlockHeader)

-- | Repeatedly fetch data from a given source function, and call an action
--   for each element retrieved.
--   
--   If the data source indicates that it has no more data at present
--   (<a>Sleep</a>), then sleep for the interval <tt>delay</tt>, and then
--   try the fetch again.
tick :: forall st m a. MonadIO m => (st -> m (TickResult a, st)) -> (a -> m ()) -> Millisecond -> st -> m ()

-- | The result type of the element fetch function provided to <a>tick</a>.
data TickResult a

-- | Have a result, and there may be more available.
GotChunk :: !a -> TickResult a

-- | There is no result available now, so wait.
Sleep :: TickResult a

-- | Retrieve blocks from a chain producer and execute some given action
--   for each block.
listen :: forall e0 e1. Show e0 => NetworkLayer IO e0 e1 -> ([Block] -> IO ()) -> IO ()
instance Data.Foldable.Foldable Cardano.NetworkLayer.TickResult
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.NetworkLayer.TickResult a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.NetworkLayer.TickResult a)


-- | Provides the wallet layer functions that are used by API layer and
--   uses both <a>Cardano.DBLayer</a> and <a>Cardano.NetworkLayer</a> to
--   realize its role as being intermediary between the three.
module Cardano.WalletLayer

-- | Types
data WalletLayer m s
WalletLayer :: (NewWallet -> ExceptT CreateWalletError m WalletId) -> (WalletId -> ExceptT GetWalletError m (Wallet s)) -> (WalletId -> m ()) -> WalletLayer m s
[$sel:createWallet:WalletLayer] :: WalletLayer m s -> NewWallet -> ExceptT CreateWalletError m WalletId
[$sel:getWallet:WalletLayer] :: WalletLayer m s -> WalletId -> ExceptT GetWalletError m (Wallet s)
[$sel:watchWallet:WalletLayer] :: WalletLayer m s -> WalletId -> m ()
data NewWallet
NewWallet :: !Mnemonic 15 -> !Passphrase "generation" -> !WalletName -> !Passphrase "encryption" -> !AddressPoolGap -> NewWallet
[$sel:mnemonic:NewWallet] :: NewWallet -> !Mnemonic 15
[$sel:mnemonic2ndFactor:NewWallet] :: NewWallet -> !Passphrase "generation"
[$sel:name:NewWallet] :: NewWallet -> !WalletName
[$sel:passphrase:NewWallet] :: NewWallet -> !Passphrase "encryption"
[$sel:gap:NewWallet] :: NewWallet -> !AddressPoolGap

-- | Errors occuring when fetching a wallet
newtype GetWalletError
ErrGetWalletNotFound :: WalletId -> GetWalletError

-- | Errors occuring when creating a wallet
newtype CreateWalletError
ErrCreateWalletIdAlreadyExists :: WalletId -> CreateWalletError

-- | Create a new instance of the wallet layer.
mkWalletLayer :: Show e0 => DBLayer IO SeqState -> NetworkLayer IO e0 e1 -> WalletLayer IO SeqState
instance GHC.Show.Show Cardano.WalletLayer.CreateWalletError
instance GHC.Classes.Eq Cardano.WalletLayer.CreateWalletError
instance GHC.Show.Show Cardano.WalletLayer.GetWalletError
instance GHC.Classes.Eq Cardano.WalletLayer.GetWalletError
instance GHC.Generics.Generic Cardano.WalletLayer.NewWallet
instance GHC.Show.Show Cardano.WalletLayer.NewWallet


-- | Extra content types for Servant.
module Servant.Extra.ContentTypes

-- | Represents a piece of binary data for which a hash value should be
--   calculated before performing any further deserialization.
data ComputeHash algorithm a

-- | Represents a CBOR (Concise Binary Object Representation) object.
--   
--   See RFC 7049 (http:/<i>cbor.io</i>) for further details.
data CBOR

-- | The class of types that can be converted to from CBOR.
class FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a

-- | Represents the result of hashing a piece of data.
newtype Hash algorithm a
Hash :: Digest algorithm -> Hash algorithm a

-- | Represents something that has been packed with the Cardano packfile
--   format.
data Packed a

-- | Represents a piece of data with an accompanying hash value.
data WithHash algorithm a
WithHash :: Digest algorithm -> a -> WithHash algorithm a
[getHash] :: WithHash algorithm a -> Digest algorithm
[getValue] :: WithHash algorithm a -> a
instance GHC.Show.Show a => GHC.Show.Show (Servant.Extra.ContentTypes.WithHash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.Packed a)
instance Servant.API.ContentTypes.MimeUnrender a b => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.Packed a) [b]
instance (Servant.API.ContentTypes.MimeUnrender a b, Crypto.Hash.Types.HashAlgorithm alg) => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.ComputeHash alg a) (Servant.Extra.ContentTypes.WithHash alg b)
instance Web.Internal.HttpApiData.ToHttpApiData (Servant.Extra.ContentTypes.Hash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.ComputeHash algorithm a)
instance Servant.Extra.ContentTypes.FromCBOR a => Servant.API.ContentTypes.MimeUnrender Servant.Extra.ContentTypes.CBOR a
instance Servant.API.ContentTypes.Accept Servant.Extra.ContentTypes.CBOR


-- | An API specification for the Cardano HTTP Bridge.
module Cardano.NetworkLayer.HttpBridge.Api
type Api = GetBlockByHash :<|> GetEpochById :<|> GetTipBlockHeader
api :: Proxy Api
newtype ApiT a
ApiT :: a -> ApiT a
[getApiT] :: ApiT a -> a

-- | Represents a unique epoch.
newtype EpochIndex
EpochIndex :: Word64 -> EpochIndex
[getEpochIndex] :: EpochIndex -> Word64

-- | Represents the name of a Cardano network.
newtype NetworkName
NetworkName :: Text -> NetworkName
[getNetworkName] :: NetworkName -> Text
instance GHC.Show.Show Cardano.NetworkLayer.HttpBridge.Api.NetworkName
instance GHC.Classes.Eq Cardano.NetworkLayer.HttpBridge.Api.NetworkName
instance GHC.Show.Show Cardano.NetworkLayer.HttpBridge.Api.EpochIndex
instance GHC.Classes.Eq Cardano.NetworkLayer.HttpBridge.Api.EpochIndex
instance GHC.Show.Show a => GHC.Show.Show (Cardano.NetworkLayer.HttpBridge.Api.ApiT a)
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.NetworkLayer.HttpBridge.Api.NetworkName
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.NetworkLayer.HttpBridge.Api.EpochIndex
instance Servant.Extra.ContentTypes.FromCBOR (Cardano.NetworkLayer.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.Block)
instance Servant.Extra.ContentTypes.FromCBOR (Cardano.NetworkLayer.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.BlockHeader)


-- | This module contains the necessary logic to talk to implement the
--   network layer using the cardano-http-bridge as a chain producer.
module Cardano.NetworkLayer.HttpBridge

-- | Endpoints of the cardano-http-bridge API.
data HttpBridge m e
HttpBridge :: (Hash "BlockHeader" -> ExceptT e m Block) -> (Word64 -> ExceptT e m [Block]) -> ExceptT e m (Hash "BlockHeader", BlockHeader) -> HttpBridge m e
[$sel:getBlock:HttpBridge] :: HttpBridge m e -> Hash "BlockHeader" -> ExceptT e m Block
[$sel:getEpoch:HttpBridge] :: HttpBridge m e -> Word64 -> ExceptT e m [Block]
[$sel:getNetworkTip:HttpBridge] :: HttpBridge m e -> ExceptT e m (Hash "BlockHeader", BlockHeader)

-- | The things that can go wrong when retrieving blocks.
data HttpBridgeError

-- | Could not connect to or read from the node API.
NodeUnavailable :: String -> HttpBridgeError

-- | The node returned an unexpected response.
BadResponseFromNode :: String -> HttpBridgeError

-- | Constructs a network layer with the given cardano-http-bridge API.
mkNetworkLayer :: Monad m => HttpBridge m e -> NetworkLayer m e e

-- | Creates a cardano-http-bridge <a>NetworkLayer</a> using the given
--   connection settings.
newNetworkLayer :: Text -> Int -> IO (NetworkLayer IO HttpBridgeError HttpBridgeError)
instance GHC.Classes.Eq Cardano.NetworkLayer.HttpBridge.HttpBridgeError
instance GHC.Show.Show Cardano.NetworkLayer.HttpBridge.HttpBridgeError
