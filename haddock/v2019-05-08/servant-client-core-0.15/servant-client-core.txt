-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core functionality and class for client function generation for servant APIs
--   
--   This library provides backend-agnostic generation of client functions.
--   For more information, see the README.
@package servant-client-core
@version 0.15

module Servant.Client.Core.Internal.BaseUrl

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String
newtype InvalidBaseUrlException
InvalidBaseUrlException :: String -> InvalidBaseUrlException

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
instance GHC.Show.Show Servant.Client.Core.Internal.BaseUrl.InvalidBaseUrlException
instance Data.Data.Data Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance GHC.Generics.Generic Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance GHC.Classes.Ord Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance GHC.Show.Show Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Data.Data.Data Servant.Client.Core.Internal.BaseUrl.Scheme
instance Language.Haskell.TH.Syntax.Lift Servant.Client.Core.Internal.BaseUrl.Scheme
instance GHC.Generics.Generic Servant.Client.Core.Internal.BaseUrl.Scheme
instance GHC.Classes.Ord Servant.Client.Core.Internal.BaseUrl.Scheme
instance GHC.Classes.Eq Servant.Client.Core.Internal.BaseUrl.Scheme
instance GHC.Show.Show Servant.Client.Core.Internal.BaseUrl.Scheme
instance GHC.Exception.Type.Exception Servant.Client.Core.Internal.BaseUrl.InvalidBaseUrlException
instance GHC.Classes.Eq Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Data.Aeson.Types.ToJSON.ToJSON Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Data.Aeson.Types.FromJSON.FromJSON Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Data.Aeson.Types.ToJSON.ToJSONKey Servant.Client.Core.Internal.BaseUrl.BaseUrl
instance Data.Aeson.Types.FromJSON.FromJSONKey Servant.Client.Core.Internal.BaseUrl.BaseUrl

module Servant.Client.Core.Internal.Generic

-- | This class allows us to match client structure with client functions
--   produced with <tt>client</tt> without explicit pattern-matching.
--   
--   The client structure needs a <a>Generic</a> instance.
--   
--   Example:
--   
--   <pre>
--   type API
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; QueryParam "b" String :&gt; Post '[JSON] [Int]
--    :&lt;|&gt; Capture "nested" Int :&gt; NestedAPI
--   
--   type NestedAPI
--       = Get '[JSON] String
--    :&lt;|&gt; "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   data APIClient = APIClient
--     { getFoo         :: Int -&gt; ClientM Int
--     , postBar        :: Maybe Char -&gt; Maybe String -&gt; ClientM [Int]
--     , mkNestedClient :: Int -&gt; NestedClient
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   data NestedClient = NestedClient
--    { getString :: ClientM String
--    , postBaz   :: Maybe Char -&gt; ClientM ()
--    } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic NestedClient
--   instance (Client NestedAPI ~ client) =&gt; ClientLike client NestedClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   By default, left-nested alternatives are expanded:
--   
--   <pre>
--   type API1
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; Post '[JSON] String
--   
--   type API2
--       = "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   type API = API1 :&lt;|&gt; API2
--   
--   data APIClient = APIClient
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     , postBaz :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   If you want to define client for <tt>API1</tt> as a separate data
--   structure, you can use <a>genericMkClientP</a>:
--   
--   <pre>
--   data APIClient1 = APIClient1
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient1
--   instance (Client API1 ~ client) =&gt; ClientLike client APIClient1
--   
--   data APIClient = APIClient
--     { mkAPIClient1 :: APIClient1
--     , postBaz      :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient where
--     mkClient = genericMkClientP
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
class ClientLike client custom
mkClient :: ClientLike client custom => client -> custom
mkClient :: (ClientLike client custom, Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Match client structure with client functions, regarding left-nested
--   API clients as separate data structures.
class GClientLikeP client xs
gMkClientP :: GClientLikeP client xs => client -> NP I xs

-- | Match client structure with client functions, expanding left-nested
--   API clients in the same structure.
class GClientLikeL (xs :: [*]) (ys :: [*])
gMkClientL :: GClientLikeL xs ys => NP I xs -> NP I ys
type family ClientList (client :: *) (acc :: [*]) :: [*]
class GClientList client (acc :: [*])
gClientList :: GClientList client acc => client -> NP I acc -> NP I (ClientList client acc)

-- | Generate client structure from client type, expanding left-nested API
--   (done by default).
genericMkClientL :: (Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Generate client structure from client type, regarding left-nested API
--   clients as separate data structures.
genericMkClientP :: (Generic custom, Code custom ~ '[xs], GClientLikeP client xs) => client -> custom
instance Servant.Client.Core.Internal.Generic.ClientLike client custom => Servant.Client.Core.Internal.Generic.ClientLike (a -> client) (a -> custom)
instance (Servant.Client.Core.Internal.Generic.GClientLikeP b (y : xs), Servant.Client.Core.Internal.Generic.ClientLike a x) => Servant.Client.Core.Internal.Generic.GClientLikeP (a Servant.API.Alternative.:<|> b) (x : y : xs)
instance Servant.Client.Core.Internal.Generic.ClientLike a x => Servant.Client.Core.Internal.Generic.GClientLikeP a '[x]
instance (Servant.Client.Core.Internal.Generic.ClientLike x y, Servant.Client.Core.Internal.Generic.GClientLikeL xs ys) => Servant.Client.Core.Internal.Generic.GClientLikeL (x : xs) (y : ys)
instance (Servant.Client.Core.Internal.Generic.GClientList b acc, Servant.Client.Core.Internal.Generic.GClientList a (Servant.Client.Core.Internal.Generic.ClientList b acc)) => Servant.Client.Core.Internal.Generic.GClientList (a Servant.API.Alternative.:<|> b) acc
instance (Servant.Client.Core.Internal.Generic.ClientList client acc Data.Type.Equality.~ (client : acc)) => Servant.Client.Core.Internal.Generic.GClientList client acc
instance Servant.Client.Core.Internal.Generic.GClientLikeL '[] '[]

module Servant.Client.Core.Internal.Request

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ServantError

-- | The server returned an error response
FailureResponse :: Response -> ServantError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ServantError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ServantError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ServantError

-- | There was a connection error, and no response was received
ConnectionError :: Text -> ServantError
data RequestF a
Request :: a -> Seq QueryItem -> Maybe (RequestBody, MediaType) -> Seq MediaType -> Seq Header -> HttpVersion -> Method -> RequestF a
[requestPath] :: RequestF a -> a
[requestQueryString] :: RequestF a -> Seq QueryItem
[requestBody] :: RequestF a -> Maybe (RequestBody, MediaType)
[requestAccept] :: RequestF a -> Seq MediaType
[requestHeaders] :: RequestF a -> Seq Header
[requestHttpVersion] :: RequestF a -> HttpVersion
[requestMethod] :: RequestF a -> Method
type Request = RequestF Builder

-- | The request body. A replica of the <tt>http-client</tt>
--   <tt>RequestBody</tt>.
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> ((IO ByteString -> IO ()) -> IO ()) -> RequestBody
RequestBodyStreamChunked :: ((IO ByteString -> IO ()) -> IO ()) -> RequestBody
RequestBodyIO :: IO RequestBody -> RequestBody
data GenResponse a
Response :: Status -> Seq Header -> HttpVersion -> a -> GenResponse a
[responseStatusCode] :: GenResponse a -> Status
[responseHeaders] :: GenResponse a -> Seq Header
[responseHttpVersion] :: GenResponse a -> HttpVersion
[responseBody] :: GenResponse a -> a
type Response = GenResponse ByteString
type StreamingResponse = GenResponse (IO ByteString)
defaultRequest :: Request
appendToPath :: Text -> Request -> Request
appendToQueryString :: Text -> Maybe Text -> Request -> Request
addHeader :: ToHttpApiData a => HeaderName -> a -> Request -> Request

-- | Set body and media type of the request being constructed.
--   
--   The body is set to the given bytestring using the
--   <a>RequestBodyLBS</a> constructor.
setRequestBodyLBS :: ByteString -> MediaType -> Request -> Request

-- | Set body and media type of the request being constructed.
setRequestBody :: RequestBody -> MediaType -> Request -> Request
instance GHC.Generics.Generic Servant.Client.Core.Internal.Request.ServantError
instance GHC.Show.Show Servant.Client.Core.Internal.Request.ServantError
instance GHC.Classes.Eq Servant.Client.Core.Internal.Request.ServantError
instance Data.Traversable.Traversable Servant.Client.Core.Internal.Request.GenResponse
instance Data.Foldable.Foldable Servant.Client.Core.Internal.Request.GenResponse
instance GHC.Base.Functor Servant.Client.Core.Internal.Request.GenResponse
instance GHC.Generics.Generic (Servant.Client.Core.Internal.Request.GenResponse a)
instance GHC.Show.Show a => GHC.Show.Show (Servant.Client.Core.Internal.Request.GenResponse a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Servant.Client.Core.Internal.Request.GenResponse a)
instance GHC.Generics.Generic (Servant.Client.Core.Internal.Request.RequestF a)
instance GHC.Generics.Generic Servant.Client.Core.Internal.Request.RequestBody
instance GHC.Exception.Type.Exception Servant.Client.Core.Internal.Request.ServantError
instance Control.DeepSeq.NFData Servant.Client.Core.Internal.Request.ServantError
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Servant.Client.Core.Internal.Request.GenResponse a)

module Servant.Client.Core.Internal.ClientF
data ClientF a
RunRequest :: Request -> (Response -> a) -> ClientF a
StreamingRequest :: Request -> (StreamingResponse -> a) -> ClientF a
Throw :: ServantError -> ClientF a
instance GHC.Base.Functor Servant.Client.Core.Internal.ClientF.ClientF


-- | Basic Authentication for clients
module Servant.Client.Core.Internal.BasicAuth

-- | Authenticate a request using Basic Authentication
basicAuthReq :: BasicAuthData -> Request -> Request


-- | Authentication for clients
module Servant.Client.Core.Internal.Auth

-- | For a resource protected by authentication (e.g. AuthProtect), we need
--   to provide the client with some data used to add authentication data
--   to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
type family AuthClientData a :: *

-- | For better type inference and to avoid usage of a data family, we
--   newtype wrap the combination of some <a>AuthClientData</a> and a
--   function to add authentication data to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
newtype AuthenticatedRequest a
AuthenticatedRequest :: (AuthClientData a, AuthClientData a -> Request -> Request) -> AuthenticatedRequest a
[unAuthReq] :: AuthenticatedRequest a -> (AuthClientData a, AuthClientData a -> Request -> Request)

-- | Handy helper to avoid wrapping datatypes in tuples everywhere.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
mkAuthenticatedRequest :: AuthClientData a -> (AuthClientData a -> Request -> Request) -> AuthenticatedRequest a


-- | Types for possible backends to run client-side <a>Request</a> queries
module Servant.Client.Core.Internal.RunClient
class Monad m => RunClient m

-- | How to make a request.
runRequest :: RunClient m => Request -> m Response
throwServantError :: RunClient m => ServantError -> m a
class RunClient m => RunStreamingClient m
withStreamingRequest :: RunStreamingClient m => Request -> (StreamingResponse -> IO a) -> m a
checkContentTypeHeader :: RunClient m => Response -> m MediaType
decodedAs :: forall ct a m. (MimeUnrender ct a, RunClient m) => Response -> Proxy ct -> m a
instance (Servant.Client.Core.Internal.ClientF.ClientF Data.Type.Equality.~ f) => Servant.Client.Core.Internal.RunClient.RunClient (Control.Monad.Free.Free f)

module Servant.Client.Core.Internal.HasClient

-- | <a>clientIn</a> allows you to produce operations to query an API from
--   a client within a <a>RunClient</a> monad.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   clientM :: Proxy ClientM
--   clientM = Proxy
--   
--   getAllBooks :: ClientM [Book]
--   postNewBook :: Book -&gt; ClientM Book
--   (getAllBooks :&lt;|&gt; postNewBook) = myApi `clientIn` clientM
--   </pre>
clientIn :: HasClient m api => Proxy api -> Proxy m -> Client m api

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type family Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient
instance GHC.Enum.Enum Servant.Client.Core.Internal.HasClient.EmptyClient
instance GHC.Enum.Bounded Servant.Client.Core.Internal.HasClient.EmptyClient
instance GHC.Show.Show Servant.Client.Core.Internal.HasClient.EmptyClient
instance GHC.Classes.Eq Servant.Client.Core.Internal.HasClient.EmptyClient
instance Servant.Client.Core.Internal.RunClient.RunClient m => Servant.Client.Core.Internal.HasClient.HasClient m Servant.API.Empty.EmptyAPI
instance (Servant.Client.Core.Internal.HasClient.HasClient m a, Servant.Client.Core.Internal.HasClient.HasClient m b) => Servant.Client.Core.Internal.HasClient.HasClient m (a Servant.API.Alternative.:<|> b)
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.Internal.HasClient.HasClient m api) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Capture.Capture' mods capture a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol capture, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.Internal.HasClient.HasClient m sublayout) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Capture.CaptureAll capture a Servant.API.Sub.:> sublayout)
instance forall k1 (m :: * -> *) ct a (method :: k1) (cts' :: [*]) (cts :: [*]) (status :: GHC.Types.Nat). (Servant.Client.Core.Internal.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.Verbs.ReflectMethod method, cts' Data.Type.Equality.~ (ct : cts)) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a)
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.Types.Nat) (cts :: [*]). (Servant.Client.Core.Internal.RunClient.RunClient m, Servant.API.Verbs.ReflectMethod method) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts Servant.API.ContentTypes.NoContent)
instance forall k1 (m :: * -> *) ct a (ls :: [*]) (method :: k1) (cts' :: [*]) (cts :: [*]) (status :: GHC.Types.Nat). (Servant.Client.Core.Internal.RunClient.RunClient m, Servant.API.ContentTypes.MimeUnrender ct a, Servant.API.ResponseHeaders.BuildHeadersTo ls, Servant.API.Verbs.ReflectMethod method, cts' Data.Type.Equality.~ (ct : cts)) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' (Servant.API.ResponseHeaders.Headers ls a))
instance forall k1 (m :: * -> *) (ls :: [*]) (method :: k1) (status :: GHC.Types.Nat) (cts :: [*]). (Servant.Client.Core.Internal.RunClient.RunClient m, Servant.API.ResponseHeaders.BuildHeadersTo ls, Servant.API.Verbs.ReflectMethod method) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts (Servant.API.ResponseHeaders.Headers ls Servant.API.ContentTypes.NoContent))
instance forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (status :: GHC.Types.Nat). (Servant.Client.Core.Internal.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Stream.Stream method status framing ct a)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.Internal.HasClient.HasClient m api, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods)) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Description.Summary desc Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Description.Description desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.Internal.HasClient.HasClient m api, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired mods)) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.ToHttpApiData a, Servant.Client.Core.Internal.HasClient.HasClient m api) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.QueryParam.QueryParams sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Client.Core.Internal.HasClient.HasClient m api) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.RunClient.RunClient m => Servant.Client.Core.Internal.HasClient.HasClient m Servant.API.Raw.Raw
instance (Servant.API.ContentTypes.MimeRender ct a, Servant.Client.Core.Internal.HasClient.HasClient m api) => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Stream.StreamBody' mods framing ctype a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol path, Servant.Client.Core.Internal.HasClient.HasClient m api) => Servant.Client.Core.Internal.HasClient.HasClient m (path Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Data.Vault.Lazy.Vault Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m subapi => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.WithNamedContext.WithNamedContext name context subapi)
instance forall k (m :: * -> *) api (tag :: k). Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api)
instance Servant.Client.Core.Internal.HasClient.HasClient m api => Servant.Client.Core.Internal.HasClient.HasClient m (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api)


-- | This module provides backend-agnostic functionality for generating
--   clients from <tt>servant</tt> APIs. By "backend," we mean something
--   that concretely executes the request, such as:
--   
--   <ul>
--   <li>The <tt>http-client</tt> library</li>
--   <li>The <tt>haxl</tt> library</li>
--   <li>GHCJS via FFI</li>
--   </ul>
--   
--   etc.
--   
--   Each backend is encapsulated in a monad that is an instance of the
--   <a>RunClient</a> class.
--   
--   This library is primarily of interest to backend-writers and
--   combinator-writers. For more information, see the README.md
module Servant.Client.Core

-- | <a>clientIn</a> allows you to produce operations to query an API from
--   a client within a <a>RunClient</a> monad.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book -- POST /books
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   clientM :: Proxy ClientM
--   clientM = Proxy
--   
--   getAllBooks :: ClientM [Book]
--   postNewBook :: Book -&gt; ClientM Book
--   (getAllBooks :&lt;|&gt; postNewBook) = myApi `clientIn` clientM
--   </pre>
clientIn :: HasClient m api => Proxy api -> Proxy m -> Client m api

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type family Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api
type Request = RequestF Builder
data RequestF a
Request :: a -> Seq QueryItem -> Maybe (RequestBody, MediaType) -> Seq MediaType -> Seq Header -> HttpVersion -> Method -> RequestF a
[requestPath] :: RequestF a -> a
[requestQueryString] :: RequestF a -> Seq QueryItem
[requestBody] :: RequestF a -> Maybe (RequestBody, MediaType)
[requestAccept] :: RequestF a -> Seq MediaType
[requestHeaders] :: RequestF a -> Seq Header
[requestHttpVersion] :: RequestF a -> HttpVersion
[requestMethod] :: RequestF a -> Method
defaultRequest :: Request

-- | The request body. A replica of the <tt>http-client</tt>
--   <tt>RequestBody</tt>.
data RequestBody
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> ((IO ByteString -> IO ()) -> IO ()) -> RequestBody
RequestBodyStreamChunked :: ((IO ByteString -> IO ()) -> IO ()) -> RequestBody
RequestBodyIO :: IO RequestBody -> RequestBody

-- | Handy helper to avoid wrapping datatypes in tuples everywhere.
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
mkAuthenticatedRequest :: AuthClientData a -> (AuthClientData a -> Request -> Request) -> AuthenticatedRequest a

-- | Authenticate a request using Basic Authentication
basicAuthReq :: BasicAuthData -> Request -> Request

-- | For better type inference and to avoid usage of a data family, we
--   newtype wrap the combination of some <a>AuthClientData</a> and a
--   function to add authentication data to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
newtype AuthenticatedRequest a
AuthenticatedRequest :: (AuthClientData a, AuthClientData a -> Request -> Request) -> AuthenticatedRequest a
[unAuthReq] :: AuthenticatedRequest a -> (AuthClientData a, AuthClientData a -> Request -> Request)

-- | For a resource protected by authentication (e.g. AuthProtect), we need
--   to provide the client with some data used to add authentication data
--   to a request
--   
--   NOTE: THIS API IS EXPERIMENTAL AND SUBJECT TO CHANGE
type family AuthClientData a :: *

-- | This class allows us to match client structure with client functions
--   produced with <tt>client</tt> without explicit pattern-matching.
--   
--   The client structure needs a <a>Generic</a> instance.
--   
--   Example:
--   
--   <pre>
--   type API
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; QueryParam "b" String :&gt; Post '[JSON] [Int]
--    :&lt;|&gt; Capture "nested" Int :&gt; NestedAPI
--   
--   type NestedAPI
--       = Get '[JSON] String
--    :&lt;|&gt; "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   data APIClient = APIClient
--     { getFoo         :: Int -&gt; ClientM Int
--     , postBar        :: Maybe Char -&gt; Maybe String -&gt; ClientM [Int]
--     , mkNestedClient :: Int -&gt; NestedClient
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   data NestedClient = NestedClient
--    { getString :: ClientM String
--    , postBaz   :: Maybe Char -&gt; ClientM ()
--    } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic NestedClient
--   instance (Client NestedAPI ~ client) =&gt; ClientLike client NestedClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   By default, left-nested alternatives are expanded:
--   
--   <pre>
--   type API1
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; Post '[JSON] String
--   
--   type API2
--       = "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   type API = API1 :&lt;|&gt; API2
--   
--   data APIClient = APIClient
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     , postBaz :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   If you want to define client for <tt>API1</tt> as a separate data
--   structure, you can use <a>genericMkClientP</a>:
--   
--   <pre>
--   data APIClient1 = APIClient1
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient1
--   instance (Client API1 ~ client) =&gt; ClientLike client APIClient1
--   
--   data APIClient = APIClient
--     { mkAPIClient1 :: APIClient1
--     , postBaz      :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient where
--     mkClient = genericMkClientP
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
class ClientLike client custom
mkClient :: ClientLike client custom => client -> custom
mkClient :: (ClientLike client custom, Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Generate client structure from client type, expanding left-nested API
--   (done by default).
genericMkClientL :: (Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Generate client structure from client type, regarding left-nested API
--   clients as separate data structures.
genericMkClientP :: (Generic custom, Code custom ~ '[xs], GClientLikeP client xs) => client -> custom

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ServantError

-- | The server returned an error response
FailureResponse :: Response -> ServantError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ServantError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ServantError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ServantError

-- | There was a connection error, and no response was received
ConnectionError :: Text -> ServantError

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient
type Response = GenResponse ByteString
data GenResponse a
Response :: Status -> Seq Header -> HttpVersion -> a -> GenResponse a
[responseStatusCode] :: GenResponse a -> Status
[responseHeaders] :: GenResponse a -> Seq Header
[responseHttpVersion] :: GenResponse a -> HttpVersion
[responseBody] :: GenResponse a -> a
class Monad m => RunClient m

-- | How to make a request.
runRequest :: RunClient m => Request -> m Response
throwServantError :: RunClient m => ServantError -> m a
data InvalidBaseUrlException

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
class RunClient m => RunStreamingClient m
withStreamingRequest :: RunStreamingClient m => Request -> (StreamingResponse -> IO a) -> m a
type StreamingResponse = GenResponse (IO ByteString)
addHeader :: ToHttpApiData a => HeaderName -> a -> Request -> Request
appendToQueryString :: Text -> Maybe Text -> Request -> Request
appendToPath :: Text -> Request -> Request

-- | Set body and media type of the request being constructed.
--   
--   The body is set to the given bytestring using the
--   <a>RequestBodyLBS</a> constructor.
setRequestBodyLBS :: ByteString -> MediaType -> Request -> Request

-- | Set body and media type of the request being constructed.
setRequestBody :: RequestBody -> MediaType -> Request -> Request


-- | This module is a utility for <tt>servant-client-core</tt> backend
--   writers. It contains all the functionality from
--   <tt>servant-client-core</tt> that should be re-exported.
module Servant.Client.Core.Reexport

-- | This class lets us define how each API combinator influences the
--   creation of an HTTP request.
--   
--   Unless you are writing a new backend for <tt>servant-client-core</tt>
--   or new combinators that you want to support client-generation, you can
--   ignore this class.
class RunClient m => HasClient m api where {
    type family Client (m :: * -> *) (api :: *) :: *;
}
clientWithRoute :: HasClient m api => Proxy m -> Proxy api -> Request -> Client m api
hoistClientMonad :: HasClient m api => Proxy m -> Proxy api -> (forall x. mon x -> mon' x) -> Client mon api -> Client mon' api
type Response = GenResponse ByteString
type StreamingResponse = GenResponse (IO ByteString)
data GenResponse a
Response :: Status -> Seq Header -> HttpVersion -> a -> GenResponse a
[responseStatusCode] :: GenResponse a -> Status
[responseHeaders] :: GenResponse a -> Seq Header
[responseHttpVersion] :: GenResponse a -> HttpVersion
[responseBody] :: GenResponse a -> a

-- | This class allows us to match client structure with client functions
--   produced with <tt>client</tt> without explicit pattern-matching.
--   
--   The client structure needs a <a>Generic</a> instance.
--   
--   Example:
--   
--   <pre>
--   type API
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; QueryParam "b" String :&gt; Post '[JSON] [Int]
--    :&lt;|&gt; Capture "nested" Int :&gt; NestedAPI
--   
--   type NestedAPI
--       = Get '[JSON] String
--    :&lt;|&gt; "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   data APIClient = APIClient
--     { getFoo         :: Int -&gt; ClientM Int
--     , postBar        :: Maybe Char -&gt; Maybe String -&gt; ClientM [Int]
--     , mkNestedClient :: Int -&gt; NestedClient
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   data NestedClient = NestedClient
--    { getString :: ClientM String
--    , postBaz   :: Maybe Char -&gt; ClientM ()
--    } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic NestedClient
--   instance (Client NestedAPI ~ client) =&gt; ClientLike client NestedClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   By default, left-nested alternatives are expanded:
--   
--   <pre>
--   type API1
--       = "foo" :&gt; Capture "x" Int :&gt; Get '[JSON] Int
--    :&lt;|&gt; "bar" :&gt; QueryParam "a" Char :&gt; Post '[JSON] String
--   
--   type API2
--       = "baz" :&gt; QueryParam "c" Char :&gt; Post '[JSON] ()
--   
--   type API = API1 :&lt;|&gt; API2
--   
--   data APIClient = APIClient
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     , postBaz :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
--   
--   If you want to define client for <tt>API1</tt> as a separate data
--   structure, you can use <a>genericMkClientP</a>:
--   
--   <pre>
--   data APIClient1 = APIClient1
--     { getFoo  :: Int -&gt; ClientM Int
--     , postBar :: Maybe Char -&gt; ClientM String
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient1
--   instance (Client API1 ~ client) =&gt; ClientLike client APIClient1
--   
--   data APIClient = APIClient
--     { mkAPIClient1 :: APIClient1
--     , postBaz      :: Maybe Char -&gt; ClientM ()
--     } deriving GHC.Generic
--   
--   instance Generics.SOP.Generic APIClient
--   instance (Client API ~ client) =&gt; ClientLike client APIClient where
--     mkClient = genericMkClientP
--   
--   mkAPIClient :: APIClient
--   mkAPIClient = mkClient (client (Proxy :: Proxy API))
--   </pre>
class ClientLike client custom
mkClient :: ClientLike client custom => client -> custom
mkClient :: (ClientLike client custom, Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Generate client structure from client type, expanding left-nested API
--   (done by default).
genericMkClientL :: (Generic custom, Code custom ~ '[xs], GClientList client '[], GClientLikeL (ClientList client '[]) xs) => client -> custom

-- | Generate client structure from client type, regarding left-nested API
--   clients as separate data structures.
genericMkClientP :: (Generic custom, Code custom ~ '[xs], GClientLikeP client xs) => client -> custom

-- | A type representing possible errors in a request
--   
--   Note that this type substantially changed in 0.12.
data ServantError

-- | The server returned an error response
FailureResponse :: Response -> ServantError

-- | The body could not be decoded at the expected type
DecodeFailure :: Text -> Response -> ServantError

-- | The content-type of the response is not supported
UnsupportedContentType :: MediaType -> Response -> ServantError

-- | The content-type header is invalid
InvalidContentTypeHeader :: Response -> ServantError

-- | There was a connection error, and no response was received
ConnectionError :: Text -> ServantError

-- | Singleton type representing a client for an empty API.
data EmptyClient
EmptyClient :: EmptyClient

-- | Simple data type to represent the target of HTTP requests for
--   servant's automatically-generated clients.
data BaseUrl
BaseUrl :: Scheme -> String -> Int -> String -> BaseUrl

-- | URI scheme to use
[baseUrlScheme] :: BaseUrl -> Scheme

-- | host (eg "haskell.org")
[baseUrlHost] :: BaseUrl -> String

-- | port (eg 80)
[baseUrlPort] :: BaseUrl -> Int

-- | path (eg "<i>a</i>b/c")
[baseUrlPath] :: BaseUrl -> String

-- | URI scheme to use
data Scheme

-- | http://
Http :: Scheme

-- | https://
Https :: Scheme

-- | <pre>
--   &gt;&gt;&gt; showBaseUrl &lt;$&gt; parseBaseUrl "api.example.com"
--   "http://api.example.com"
--   </pre>
showBaseUrl :: BaseUrl -> String

-- | <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <i>Note:</i> trailing slash is removed
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = ""}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseBaseUrl "api.example.com/dir/"
--   BaseUrl {baseUrlScheme = Http, baseUrlHost = "api.example.com", baseUrlPort = 80, baseUrlPath = "/dir"}
--   </pre>
parseBaseUrl :: MonadThrow m => String -> m BaseUrl
data InvalidBaseUrlException

module Servant.Client.Free
client :: HasClient (Free ClientF) api => Proxy api -> Client (Free ClientF) api
data ClientF a
RunRequest :: Request -> (Response -> a) -> ClientF a
StreamingRequest :: Request -> (StreamingResponse -> a) -> ClientF a
Throw :: ServantError -> ClientF a

module Servant.Client.Generic

-- | A type that specifies that an API reocrd contains a client
--   implementation.
data AsClientT (m :: * -> *)

-- | Generate a record of client functions.
genericClient :: forall routes m. (HasClient m (ToServantApi routes), GenericServant routes (AsClientT m), Client m (ToServantApi routes) ~ ToServant routes (AsClientT m)) => routes (AsClientT m)

-- | <a>genericClient</a> but with <a>hoistClientMonad</a> in between.
genericClientHoist :: forall routes m n. (HasClient m (ToServantApi routes), GenericServant routes (AsClientT n), Client n (ToServantApi routes) ~ ToServant routes (AsClientT n)) => (forall x. m x -> n x) -> routes (AsClientT n)
instance Servant.API.Generic.GenericMode (Servant.Client.Generic.AsClientT m)
