-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Network byte order utilities
--   
--   Peek and poke functions for network byte order.
@package network-byte-order
@version 0.0.0.0


-- | Peek and poke functions for network byte order.
module Network.ByteOrder
type Buffer = Ptr Word8
type Offset = Int

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf (poke8 0)
--   
--   &gt;&gt;&gt; unpack buf
--   [0,2,3,4]
--   </pre>
poke8 :: Word8 -> Buffer -> Offset -> IO ()

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf (poke16 (7*256 + 8))
--   
--   &gt;&gt;&gt; unpack buf
--   [7,8,3,4]
--   </pre>
poke16 :: Word16 -> Buffer -> Offset -> IO ()

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf (poke24 (6*65536 + 7*256 + 8))
--   
--   &gt;&gt;&gt; unpack buf
--   [6,7,8,4]
--   </pre>
poke24 :: Word32 -> Buffer -> Offset -> IO ()

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf (poke32 (6*65536 + 7*256 + 8))
--   
--   &gt;&gt;&gt; unpack buf
--   [0,6,7,8]
--   </pre>
poke32 :: Word32 -> Buffer -> Offset -> IO ()

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf (poke64 (6*65536 + 7*256 + 8))
--   
--   &gt;&gt;&gt; unpack buf
--   [0,0,0,0,0,6,7,8]
--   </pre>
poke64 :: Word64 -> Buffer -> Offset -> IO ()

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf peek8
--   1
--   </pre>
peek8 :: Buffer -> Offset -> IO Word8

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf peek16
--   258
--   </pre>
peek16 :: Buffer -> Offset -> IO Word16

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf peek24
--   66051
--   </pre>
peek24 :: Buffer -> Offset -> IO Word32

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf peek32
--   16909060
--   </pre>
peek32 :: Buffer -> Offset -> IO Word32

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; unsafeWithByteString buf peek64
--   72623859790382856
--   </pre>
peek64 :: Buffer -> Offset -> IO Word64

-- | <pre>
--   &gt;&gt;&gt; let w = 5 :: Word8
--   
--   &gt;&gt;&gt; unpack $ bytestring8 w
--   [5]
--   </pre>
bytestring8 :: Word8 -> ByteString

-- | <pre>
--   &gt;&gt;&gt; let w = foldl' (\x y -&gt; x * 256 + y) 0 [5,6] :: Word16
--   
--   &gt;&gt;&gt; unpack $ bytestring16 w
--   [5,6]
--   </pre>
bytestring16 :: Word16 -> ByteString

-- | <pre>
--   &gt;&gt;&gt; let w = foldl' (\x y -&gt; x * 256 + y) 0 [5,6,7,8] :: Word32
--   
--   &gt;&gt;&gt; unpack $ bytestring32 w
--   [5,6,7,8]
--   </pre>
bytestring32 :: Word32 -> ByteString

-- | <pre>
--   &gt;&gt;&gt; let w = foldl' (\x y -&gt; x * 256 + y) 0 [1,2,3,4,5,6,7,8] :: Word64
--   
--   &gt;&gt;&gt; unpack $ bytestring64 w
--   [1,2,3,4,5,6,7,8]
--   </pre>
bytestring64 :: Word64 -> ByteString

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; word8 buf
--   1
--   </pre>
word8 :: ByteString -> Word8

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; word16 buf
--   258
--   </pre>
word16 :: ByteString -> Word16

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; word32 buf
--   16909060
--   </pre>
word32 :: ByteString -> Word32

-- | <pre>
--   &gt;&gt;&gt; let buf = pack [1,2,3,4,5,6,7,8]
--   
--   &gt;&gt;&gt; word64 buf
--   72623859790382856
--   </pre>
word64 :: ByteString -> Word64

-- | Using <a>ByteString</a> as <a>Buffer</a> and call the <a>IO</a> action
--   of the second argument by passing the start point and the offset of
--   the <a>ByteString</a>. Note that if a <a>ByteString</a> is created
--   newly, its offset is 0.
unsafeWithByteString :: ByteString -> (Buffer -> Offset -> IO a) -> IO a
