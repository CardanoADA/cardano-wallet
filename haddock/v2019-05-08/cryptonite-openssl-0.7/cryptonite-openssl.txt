-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Crypto stuff using OpenSSL cryptographic library
--   
--   Crypto stuff using the OpenSSL cryptographic library as bindings
@package cryptonite-openssl
@version 0.7

module Crypto.OpenSSL.BN
withIntegerAsBN :: Integer -> (Ptr BIGNUM -> IO a) -> IO a
bnToInt :: Ptr BIGNUM -> IO Integer
withBnCtxNew :: (Ptr BN_CTX -> IO a) -> IO a
withBnNew :: (Ptr BIGNUM -> IO a) -> IO a


module Crypto.OpenSSL.ECC

-- | An elliptic curve point
data EcPoint

-- | An ellitic curve group
data EcGroup

-- | An elliptic curve key
data EcKey

-- | try to get a curve group from an ASN1 description string (OID)
--   
--   e.g.
--   
--   <ul>
--   <li>"1.3.132.0.35" == SEC_P521_R1</li>
--   <li>"1.2.840.10045.3.1.7" == SEC_P256_R1</li>
--   </ul>
ecGroupFromCurveOID :: String -> Maybe EcGroup

-- | Create a new GFp group with explicit (p,a,b,(x,y),order,h)
--   
--   Generally, this interface should not be used, and user should really
--   not stray away from already defined curves.
--   
--   Use at your own risks.
ecGroupGFp :: Integer -> Integer -> Integer -> (Integer, Integer) -> Integer -> Integer -> EcGroup

-- | Create a new GF2m group with explicit (p,a,b,(x,y),order,h)
--   
--   same warning as <a>ecGroupGFp</a>
ecGroupGF2m :: Integer -> Integer -> Integer -> (Integer, Integer) -> Integer -> Integer -> EcGroup

-- | get the group degree (number of bytes)
ecGroupGetDegree :: EcGroup -> Int

-- | get the order of the subgroup generated by the generator
ecGroupGetOrder :: EcGroup -> Integer
ecGroupGetCoFactor :: EcGroup -> Integer

-- | Get the group generator
ecGroupGetGenerator :: EcGroup -> EcPoint

-- | get curve's (prime,a,b)
ecGroupGetCurveGFp :: EcGroup -> (Integer, Integer, Integer)

-- | get curve's (polynomial,a,b)
ecGroupGetCurveGF2m :: EcGroup -> (Integer, Integer, Integer)

-- | add 2 points together, r = p1 + p2
ecPointAdd :: EcGroup -> EcPoint -> EcPoint -> EcPoint

-- | Add many points together
ecPointsSum :: EcGroup -> [EcPoint] -> EcPoint

-- | compute the doubling of the point p, r = p^2
ecPointDbl :: EcGroup -> EcPoint -> EcPoint

-- | compute q * m
ecPointMul :: EcGroup -> EcPoint -> Integer -> EcPoint

-- | compute generator * n + q * m
ecPointMulWithGenerator :: EcGroup -> Integer -> EcPoint -> Integer -> EcPoint

-- | compute sum ((q,m) -&gt; q * m) l
ecPointsMulAndSum :: EcGroup -> [(EcPoint, Integer)] -> EcPoint

-- | Compute the sum of the point to the nth power
--   
--   <pre>
--   f [p1,p2,..,pi] n = p1 * (n ^ 0) + p2 * (n ^ 1) + .. + pi * (n ^ i-1)
--   </pre>
ecPointsMulOfPowerAndSum :: EcGroup -> [EcPoint] -> Integer -> EcPoint

-- | compute generator * n
ecPointGeneratorMul :: EcGroup -> Integer -> EcPoint

-- | compute the inverse on the curve on the point p, r = p^(-1)
ecPointInvert :: EcGroup -> EcPoint -> EcPoint
ecPointInfinity :: EcGroup -> EcPoint

-- | get if the point is at infinity
ecPointIsAtInfinity :: EcGroup -> EcPoint -> Bool

-- | get if the point is on the curve
ecPointIsOnCurve :: EcGroup -> EcPoint -> Bool

-- | return if a point eq another point
ecPointEq :: EcGroup -> EcPoint -> EcPoint -> Bool
data PointConversionForm
PointConversion_Compressed :: PointConversionForm
PointConversion_Uncompressed :: PointConversionForm
PointConversion_Hybrid :: PointConversionForm

-- | Create a binary represention of a point using the specific format
ecPointToOct :: ByteArray outBytes => EcGroup -> EcPoint -> PointConversionForm -> outBytes

-- | Try to parse a binary representation to a point
ecPointFromOct :: ByteArrayAccess inBytes => EcGroup -> inBytes -> Either String EcPoint
ecPointFromJProjectiveGFp :: EcGroup -> (Integer, Integer, Integer) -> EcPoint
ecPointToJProjectiveGFp :: EcGroup -> EcPoint -> (Integer, Integer, Integer)

-- | Convert a (x,y) to a point representation on a prime curve.
ecPointFromAffineGFp :: EcGroup -> (Integer, Integer) -> EcPoint

-- | Convert a point of a prime curve to affine representation (x,y)
ecPointToAffineGFp :: EcGroup -> EcPoint -> (Integer, Integer)
ecPointFromAffineGF2m :: EcGroup -> (Integer, Integer) -> EcPoint
ecPointToAffineGF2m :: EcGroup -> EcPoint -> (Integer, Integer)

-- | generate a new key in a specific group
ecKeyGenerateNew :: EcGroup -> IO EcKey

-- | create a key from a group and a private integer and public point
--   keypair
ecKeyFromPair :: EcGroup -> (Integer, EcPoint) -> EcKey

-- | return the private integer and public point of a key
ecKeyToPair :: EcKey -> (Integer, EcPoint)
instance GHC.Classes.Eq Crypto.OpenSSL.ECC.PointConversionForm
instance GHC.Show.Show Crypto.OpenSSL.ECC.PointConversionForm


-- | Small Ad-Hoc bindings to AES-GCM encryption and decryption function.
--   
--   Doesn't support incremental mode yet.
--   
--   TODO: full fledge AES bindings (CBC, CTR, GCM...), with incremental
--   processing.
module Crypto.OpenSSL.AES

-- | Get whether the OpenSSL version linked supports GCM mode (at least
--   1.0.x and above)
isSupportedGCM :: Bool

-- | One shot function to GCM data without any incremental handling
encryptGCM :: ByteString -> ByteString -> ByteString -> ByteString -> ByteString

-- | One shot function to decrypt GCM data without any incremental handling
decryptGCM :: ByteString -> ByteString -> ByteString -> ByteString -> Maybe ByteString
newtype OpenSSLGcmError
OpenSSLGcmError :: String -> OpenSSLGcmError


module Crypto.OpenSSL
data OpenSSLError
OpenSSLError :: Int -> OpenSSLError
newtype OpenSSLGcmError
OpenSSLGcmError :: String -> OpenSSLGcmError

module Crypto.OpenSSL.Random
randBytes :: ByteArray byteArray => Int -> IO byteArray
