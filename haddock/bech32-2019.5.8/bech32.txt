-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Implementation of the Bech32 segwit address format (BIP 0173).
--   
--   Implementation of the Bech32 segwit address format (BIP 0173).
@package bech32
@version 2019.5.8


-- | Implementation of the <a>Bech32</a> address format.
--   
--   From an original implementation by Marko Bencun:
--   
--   <a>sipa/bech32</a>
module Codec.Binary.Bech32.Internal

-- | Encode a human-readable string and data payload into a Bech32 string.
encode :: HumanReadablePart -> ByteString -> Either EncodingError ByteString

-- | Represents the set of error conditions that may occur while encoding a
--   Bech32 string.
data EncodingError
EncodedStringTooLong :: EncodingError

-- | Decode a Bech32 string into a human-readable string and data payload.
decode :: ByteString -> Either DecodingError (HumanReadablePart, ByteString)

-- | Represents the set of errors that may occur while decoding a Bech32
--   string with the <a>decode</a> function.
data DecodingError
StringToDecodeTooLong :: DecodingError
StringToDecodeTooShort :: DecodingError
StringToDecodeHasMixedCase :: DecodingError
StringToDecodeMissingSeparatorChar :: DecodingError

-- | In cases where it is possible to determine the exact locations of
--   erroneous characters, this list will encode those locations. Clients
--   can use this information to provide user feedback. In cases where it
--   isn't possible to reliably determine the locations of erroneous
--   characters, this list will be empty.
StringToDecodeContainsInvalidChars :: [CharPosition] -> DecodingError

-- | The length of the checksum portion of an encoded string, in bytes.
checksumLength :: Int

-- | The maximum length of an encoded string, in bytes. This length
--   includes the human-readable part, the separator character, the encoded
--   data portion, and the checksum.
encodedStringMaxLength :: Int

-- | The minimum length of an encoded string, in bytes. This length
--   includes the human-readable part, the separator character, the encoded
--   data portion, and the checksum.
encodedStringMinLength :: Int

-- | The length of the separator portion of an encoded string, in bytes.
separatorLength :: Int

-- | Represents the human-readable part of a Bech32 string, as defined
--   here: <a>https://git.io/fj8FS</a>
data HumanReadablePart

-- | Represents the set of error conditions that may occur while parsing
--   the human-readable part of a Bech32 string.
data HumanReadablePartError
HumanReadablePartTooShort :: HumanReadablePartError
HumanReadablePartTooLong :: HumanReadablePartError
HumanReadablePartContainsInvalidChars :: [CharPosition] -> HumanReadablePartError

-- | Parses the human-readable part of a Bech32 string, as defined here:
--   <a>https://git.io/fj8FS</a>
mkHumanReadablePart :: ByteString -> Either HumanReadablePartError HumanReadablePart

-- | Get the raw bytes of the human-readable part of a Bech32 string.
humanReadablePartToBytes :: HumanReadablePart -> ByteString

-- | The lower bound of the set of characters permitted to appear within
--   the human-readable part of a Bech32 string.
humanReadableCharsetMinBound :: Word8

-- | The upper bound of the set of characters permitted to appear within
--   the human-readable part of a Bech32 string.
humanReadableCharsetMaxBound :: Word8

-- | The shortest length permitted for the human-readable part of a Bech32
--   string.
humanReadablePartMinLength :: Int

-- | The longest length permitted for the human-readable part of a Bech32
--   string.
humanReadablePartMaxLength :: Int

-- | Big-endian conversion of a word string from base '2^frombits' to base
--   '2^tobits'. The <tt>frombits</tt> and <tt>twobits</tt> parameters must
--   be positive, while '2^frombits' and '2^tobits' must be smaller than
--   the size of <a>Word</a>. Every value in <tt>dat</tt> must be strictly
--   smaller than '2^frombits'.
convertBits :: Functor f => [Word] -> Int -> Int -> Pad f -> f [Word]
data Word5
word5 :: Integral a => a -> Word5
getWord5 :: Word5 -> Word8
toBase256 :: [Word5] -> Maybe [Word8]
toBase32 :: [Word8] -> [Word5]
noPadding :: Pad Maybe
yesPadding :: Pad Identity

-- | The zero-based position of a character in a string, counting from the
--   left.
newtype CharPosition
CharPosition :: Int -> CharPosition

-- | The set of characters that are permitted to appear within the data
--   part of a Bech32 string. See here for more details:
--   <a>https://git.io/fj8FS</a>
charset :: String

-- | If the specified character is permitted to appear within the data part
--   of a Bech32 string, this function returns that character's
--   corresponding <a>Word5</a> value. If the specified character is not
--   permitted, returns <a>Nothing</a>. This function is case-insensitive.
charToWord5 :: Char -> Maybe Word5

-- | Encodes a function that maps every <a>Word5</a> value onto a unique
--   corresponding character value. The codomain of this function is the
--   set of characters permitted to appear within the data part of a Bech32
--   string.
word5ToChar :: Array Word5 Char
instance GHC.Show.Show Codec.Binary.Bech32.Internal.Word5
instance GHC.Classes.Ord Codec.Binary.Bech32.Internal.Word5
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.Word5
instance GHC.Show.Show Codec.Binary.Bech32.Internal.HumanReadablePartError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.HumanReadablePartError
instance GHC.Show.Show Codec.Binary.Bech32.Internal.DecodingError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.DecodingError
instance GHC.Show.Show Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Classes.Ord Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.CharPosition
instance GHC.Show.Show Codec.Binary.Bech32.Internal.EncodingError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.EncodingError
instance GHC.Classes.Eq Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Show.Show Codec.Binary.Bech32.Internal.HumanReadablePart
instance GHC.Arr.Ix Codec.Binary.Bech32.Internal.Word5


-- | Implementation of the <a>Bech32</a> address format.
--   
--   From an original implementation by Marko Bencun:
--   
--   <a>sipa/bech32</a>
module Codec.Binary.Bech32

-- | Encode a human-readable string and data payload into a Bech32 string.
encode :: HumanReadablePart -> ByteString -> Either EncodingError ByteString

-- | Decode a Bech32 string into a human-readable string and data payload.
decode :: ByteString -> Either DecodingError (HumanReadablePart, ByteString)

-- | Represents the human-readable part of a Bech32 string, as defined
--   here: <a>https://git.io/fj8FS</a>
data HumanReadablePart

-- | Parses the human-readable part of a Bech32 string, as defined here:
--   <a>https://git.io/fj8FS</a>
mkHumanReadablePart :: ByteString -> Either HumanReadablePartError HumanReadablePart

-- | Get the raw bytes of the human-readable part of a Bech32 string.
humanReadablePartToBytes :: HumanReadablePart -> ByteString
