-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet
@version 2.0.0


-- | Decoder for the rust-cardano packfile format.
--   
--   A pack file is a collection of bytestring blobs.
--   
--   The reference implementation is in <a>packfile.rs</a>.
module Cardano.Wallet.Binary.Packfile

-- | Decode a Cardano version 1 pack file. The blobs are returned as a
--   list. Decoding is not incremental, and all data is stored in memory.
decodePackfile :: ByteString -> Either PackfileError [ByteString]

-- | Things related to the file format that can go wrong when decoding a
--   pack file.
data PackfileError
MissingMagicError :: PackfileError
WrongFileTypeError :: PackfileError
VersionTooOldError :: PackfileError
VersionTooNewError :: PackfileError
BlobDecodeError :: String -> PackfileError
instance GHC.Classes.Eq Cardano.Wallet.Binary.Packfile.PackfileError
instance GHC.Show.Show Cardano.Wallet.Binary.Packfile.PackfileError


-- | This module provides mnemonic (backup phrase) creation, and conversion
--   of a mnemonic to seed for wallet restoration.
module Cardano.Wallet.Primitive.Mnemonic

-- | A backup-phrase in the form of a non-empty of Mnemonic words
--   Constructor isn't exposed.
data Mnemonic (mw :: Nat)
data Entropy (n :: Nat)
type family EntropySize (n :: Nat) :: Nat
type family MnemonicWords (n :: Nat) :: Nat
type ValidEntropySize (n :: Nat) = (KnownNat n, NatWithinBound Int n, Elem n 96 : 128 : 160 : 192 : 224 : 256 : ([] :: [Nat]))
type ValidChecksumSize (ent :: Nat) (csz :: Nat) = (KnownNat csz, NatWithinBound Int csz, Elem csz 3 : 4 : 5 : 6 : 7 : 8 : ([] :: [Nat]), CheckSumBits ent ~ csz)
type ConsistentEntropy (ent :: Nat) (mw :: Nat) (csz :: Nat) = (ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, MnemonicWords ent ~ mw)
type family CheckSumBits (n :: Nat) :: Nat

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MnemonicError csz

-- | This wraps EntropyError of <a>Cardano.Encoding.BIP39</a>
newtype MnemonicException csz

-- | Invalid entropy length or checksum
UnexpectedEntropyError :: EntropyError csz -> MnemonicException csz
data EntropyError (csz :: Nat)
ErrInvalidEntropyLength :: Int -> Int -> EntropyError
ErrInvalidEntropyChecksum :: Checksum csz -> Checksum csz -> EntropyError
data DictionaryError
ErrInvalidDictionaryWord :: String -> DictionaryError
data MnemonicWordsError
ErrWrongNumberOfWords :: Int -> Int -> MnemonicWordsError

-- | Smart-constructor for the Entropy
mkEntropy :: forall n csz. (ValidEntropySize n, ValidChecksumSize n csz) => ByteString -> Either (EntropyError csz) (Entropy n)

-- | Smart-constructor for the Mnemonic
mkMnemonic :: forall mw n csz. (ConsistentEntropy n mw csz, EntropySize mw ~ n) => [Text] -> Either (MnemonicError csz) (Mnemonic mw)

-- | Generate Entropy of a given size using a random seed.
--   
--   Example: do ent &lt;- genEntropy :: IO (Entropy 12)
genEntropy :: forall n csz. (ValidEntropySize n, ValidChecksumSize n csz) => IO (Entropy n)
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Convert an Entropy to a corresponding Mnemonic Sentence
entropyToMnemonic :: forall mw n csz. (ValidMnemonicSentence mw, ValidEntropySize n, ValidChecksumSize n csz, n ~ EntropySize mw, mw ~ MnemonicWords n) => Entropy n -> Mnemonic mw

-- | Convert <a>Entropy</a> to a raw <a>ByteString</a>
entropyToBytes :: Entropy n -> ScrubbedBytes
ambiguousNatVal :: forall n. KnownNat n => Integer
mnemonicToText :: Mnemonic mw -> [Text]
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.MnemonicError csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Wallet.Primitive.Mnemonic.MnemonicException csz)


-- | Representation of values with an associated (free) unit of measure.
--   Useful to disambiguate primitive types like <a>Int</a> or <a>Value</a>
--   which can be in different bases depending on the context.
module Data.Quantity

-- | Represents a value that has an associated unit of measure, based on
--   some underlying type.
--   
--   <pre>
--   &gt;&gt;&gt; newtype Amount = Amount (Quantity "lovelace" Word32)
--   </pre>
newtype Quantity (u :: Symbol) a
Quantity :: a -> Quantity a

-- | Opaque Haskell type to represent values between 0 and 100 (incl).
data Percentage
data MkPercentageError
PercentageOutOfBoundsError :: MkPercentageError

-- | Safe constructor for <a>Percentage</a>
mkPercentage :: Integral i => i -> Either MkPercentageError Percentage
instance GHC.Classes.Eq Data.Quantity.MkPercentageError
instance GHC.Show.Show Data.Quantity.MkPercentageError
instance Data.Aeson.Types.ToJSON.ToJSON Data.Quantity.Percentage
instance GHC.Classes.Eq Data.Quantity.Percentage
instance GHC.Show.Show Data.Quantity.Percentage
instance GHC.Generics.Generic Data.Quantity.Percentage
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Quantity.Quantity u a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Quantity.Quantity u a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Quantity.Quantity u a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Quantity.Quantity u a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Quantity.Quantity u a)
instance GHC.Generics.Generic (Data.Quantity.Quantity u a)
instance Control.DeepSeq.NFData Data.Quantity.Percentage
instance Data.Aeson.Types.FromJSON.FromJSON Data.Quantity.Percentage
instance GHC.Enum.Bounded Data.Quantity.Percentage
instance GHC.Enum.Enum Data.Quantity.Percentage
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Quantity.Quantity u a)
instance (GHC.TypeLits.KnownSymbol u, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Data.Quantity.Quantity u a)
instance (GHC.TypeLits.KnownSymbol u, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Quantity.Quantity u a)


-- | Extend the <a>Text</a> module with an extra abstraction to encode and
--   decode values safely to and from <a>Text</a>. It's very similar to
--   <tt>FromJSON</tt> and <tt>ToJSON</tt> from <a>Aeson</a>.
module Data.Text.Class

-- | Defines a textual encoding for a type.
class ToText a

-- | Encode the specified value as text.
toText :: ToText a => a -> Text

-- | Defines a textual decoding for a type.
class FromText a

-- | Decode the specified text as a value.
fromText :: FromText a => Text -> Either TextDecodingError a

-- | Indicates an error that occurred while decoding from text.
newtype TextDecodingError
TextDecodingError :: String -> TextDecodingError
[getTextDecodingError] :: TextDecodingError -> String
instance Formatting.Buildable.Buildable Data.Text.Class.TextDecodingError
instance GHC.Show.Show Data.Text.Class.TextDecodingError
instance GHC.Classes.Eq Data.Text.Class.TextDecodingError
instance Data.Text.Class.FromText Data.Text.Internal.Text
instance Data.Text.Class.FromText GHC.Types.Int
instance Data.Text.Class.ToText Data.Text.Internal.Text
instance Data.Text.Class.ToText GHC.Types.Int


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive.Types
data Block
Block :: !BlockHeader -> ![Tx] -> Block
[$sel:header:Block] :: Block -> !BlockHeader
[$sel:transactions:Block] :: Block -> ![Tx]
data BlockHeader
BlockHeader :: SlotId -> !Hash "BlockHeader" -> BlockHeader
[$sel:slotId:BlockHeader] :: BlockHeader -> SlotId
[$sel:prevBlockHash:BlockHeader] :: BlockHeader -> !Hash "BlockHeader"
data Tx
Tx :: ![TxIn] -> ![TxOut] -> Tx

-- | Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[$sel:inputs:Tx] :: Tx -> ![TxIn]

-- | Order of outputs matter in the transaction representations. Outputs
--   are used as inputs for next transactions which refer to them using
--   their indexes. It matters also for serialization.
[$sel:outputs:Tx] :: Tx -> ![TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[$sel:inputId:TxIn] :: TxIn -> !Hash "Tx"
[$sel:inputIx:TxIn] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[$sel:address:TxOut] :: TxOut -> !Address
[$sel:coin:TxOut] :: TxOut -> !Coin
data TxMeta
TxMeta :: !TxStatus -> !Direction -> !SlotId -> !Quantity "lovelace" Natural -> TxMeta
[$sel:status:TxMeta] :: TxMeta -> !TxStatus
[$sel:direction:TxMeta] :: TxMeta -> !Direction
[$sel:slotId:TxMeta] :: TxMeta -> !SlotId
[$sel:amount:TxMeta] :: TxMeta -> !Quantity "lovelace" Natural

-- | The flow of funds in to or out of a wallet.
data Direction

-- | Funds exit the wallet.
Outgoing :: Direction

-- | Funds enter the wallet.
Incoming :: Direction
data TxStatus
Pending :: TxStatus
InLedger :: TxStatus
Invalidated :: TxStatus

-- | Wrapper around the final CBOR representation of a signed tx
newtype SignedTx
SignedTx :: ByteString -> SignedTx
[$sel:signedTx:SignedTx] :: SignedTx -> ByteString
data TxWitness
PublicKeyWitness :: ByteString -> Hash "signature" -> TxWitness
ScriptWitness :: ByteString -> TxWitness
RedeemWitness :: ByteString -> TxWitness
txIns :: Set Tx -> Set TxIn
newtype Address
Address :: ByteString -> Address
[$sel:getAddress:Address] :: Address -> ByteString
data AddressState
Used :: AddressState
Unused :: AddressState

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[$sel:getCoin:Coin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[$sel:getUTxO:UTxO] :: UTxO -> Map TxIn TxOut

-- | Compute the balance of a UTxO
balance :: UTxO -> Natural

-- | Compute the balance of a unwrapped UTxO
balance' :: [(TxIn, TxOut)] -> Word64

-- | Pick a random element from a UTxO, returns <a>Nothing</a> if the UTxO
--   is empty. Otherwise, returns the selected entry and, the UTxO minus
--   the selected one.
pickRandom :: MonadRandom m => UTxO -> m (Maybe (TxIn, TxOut), UTxO)

-- | ins⋪ u
excluding :: UTxO -> Set TxIn -> UTxO

-- | a ⊆ b
isSubsetOf :: UTxO -> UTxO -> Bool

-- | ins⊲ u
restrictedBy :: UTxO -> Set TxIn -> UTxO

-- | u ⊳ outs
restrictedTo :: UTxO -> Set TxOut -> UTxO
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !Word64 -> !Word16 -> SlotId
[$sel:epochNumber:SlotId] :: SlotId -> !Word64
[$sel:slotNumber:SlotId] :: SlotId -> !Word16

-- | Compute the approximate ratio / progress between two slots. This is an
--   approximation for a few reasons, one of them being that we hard code
--   the epoch length as a static number whereas it may vary in practice.
slotRatio :: SlotId -> SlotId -> Quantity "percent" Percentage
data WalletMetadata
WalletMetadata :: !WalletName -> !WalletPassphraseInfo -> !WalletState -> !WalletDelegation PoolId -> WalletMetadata
[$sel:name:WalletMetadata] :: WalletMetadata -> !WalletName
[$sel:passphraseInfo:WalletMetadata] :: WalletMetadata -> !WalletPassphraseInfo
[$sel:status:WalletMetadata] :: WalletMetadata -> !WalletState
[$sel:delegation:WalletMetadata] :: WalletMetadata -> !WalletDelegation PoolId
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[$sel:getWalletId:WalletId] :: WalletId -> Digest Blake2b_160
newtype WalletName
WalletName :: Text -> WalletName
[$sel:getWalletName:WalletName] :: WalletName -> Text
walletNameMinLength :: Int
walletNameMaxLength :: Int
data WalletState
Ready :: WalletState
Restoring :: !Quantity "percent" Percentage -> WalletState
data WalletDelegation poolId
NotDelegating :: WalletDelegation poolId
Delegating :: !poolId -> WalletDelegation poolId
newtype WalletPassphraseInfo
WalletPassphraseInfo :: UTCTime -> WalletPassphraseInfo
[$sel:lastUpdatedAt:WalletPassphraseInfo] :: WalletPassphraseInfo -> UTCTime
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural

-- | Represent stake pool identifier. Note that the internal representation
--   is left open currently, until we figure out a better type for those.
newtype PoolId
PoolId :: Text -> PoolId
[$sel:getPoolId:PoolId] :: PoolId -> Text
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[$sel:getHash:Hash] :: Hash -> ByteString

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a

-- | Check whether an invariants holds or not.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: String -> a -> (a -> Bool) -> a

-- | Compute distance between two numeric values |a - b|
distance :: (Ord a, Num a) => a -> a -> a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Block
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxWitness
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxWitness
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Types.Hash tag)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.AddressState
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SignedTx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SignedTx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SignedTx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Direction
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Direction
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Direction
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletBalance
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance GHC.Show.Show poolId => GHC.Show.Show (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Classes.Eq poolId => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletState
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.WalletDelegation
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.ShowFmt a)
instance (Formatting.Buildable.Buildable a, Data.Foldable.Foldable f) => GHC.Show.Show (Cardano.Wallet.Primitive.Types.ShowFmt (f a))
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Block
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO
instance Cardano.Wallet.Primitive.Types.Dom Cardano.Wallet.Primitive.Types.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxIn
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TxIn, Cardano.Wallet.Primitive.Types.TxOut)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.Hash tag)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash "Tx")
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxMeta
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxMeta
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Coin
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.AddressState
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.AddressState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Address
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Address
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Address
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Direction
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Direction
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletPassphraseInfo
instance Control.DeepSeq.NFData poolId => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.WalletDelegation poolId)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletName

module Cardano.Wallet.Network
data NetworkLayer m
NetworkLayer :: (SlotId -> ExceptT ErrNetworkUnreachable m [Block]) -> ExceptT ErrNetworkTip m (Hash "BlockHeader", BlockHeader) -> (SignedTx -> ExceptT ErrPostTx m ()) -> NetworkLayer m

-- | Gets some blocks from the node. It will not necessarily return all the
--   blocks that the node has, but will receive a reasonable-sized chunk.
--   It will never return blocks from before the given slot. It may return
--   an empty list if the node does not have any blocks from after the
--   starting slot.
[nextBlocks] :: NetworkLayer m -> SlotId -> ExceptT ErrNetworkUnreachable m [Block]

-- | Get the current network tip from the chain producer
[networkTip] :: NetworkLayer m -> ExceptT ErrNetworkTip m (Hash "BlockHeader", BlockHeader)

-- | Broadcast a transaction to the chain producer
[postTx] :: NetworkLayer m -> SignedTx -> ExceptT ErrPostTx m ()

-- | Network is not reachable
newtype ErrNetworkUnreachable
ErrNetworkUnreachable :: Text -> ErrNetworkUnreachable

-- | Error while trying to get the network tip
data ErrNetworkTip
ErrNetworkTipNetworkUnreachable :: ErrNetworkUnreachable -> ErrNetworkTip
ErrNetworkTipNotFound :: ErrNetworkTip

-- | Error while trying to send a transaction
data ErrPostTx
ErrPostTxNetworkUnreachable :: ErrNetworkUnreachable -> ErrPostTx
ErrPostTxBadRequest :: Text -> ErrPostTx
ErrPostTxProtocolFailure :: Text -> ErrPostTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrPostTx
instance GHC.Show.Show Cardano.Wallet.Network.ErrPostTx
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrPostTx
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Show.Show Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrNetworkUnreachable
instance GHC.Show.Show Cardano.Wallet.Network.ErrNetworkUnreachable
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrNetworkUnreachable
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrPostTx
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrNetworkTip
instance GHC.Exception.Type.Exception Cardano.Wallet.Network.ErrNetworkUnreachable


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.CoinSelection
newtype CoinSelectionOptions
CoinSelectionOptions :: Word64 -> CoinSelectionOptions
[maximumNumberOfInputs] :: CoinSelectionOptions -> Word64
data CoinSelectionError

-- | UTxO exhausted during input selection We record the balance of the
--   UTxO as well as the size of the payment we tried to make.
NotEnoughMoney :: Word64 -> Word64 -> CoinSelectionError

-- | UTxO is not enough fragmented for the number of transaction outputs We
--   record the number of UTxO entries as well as the number of the outputs
--   of the transaction.
UtxoNotEnoughFragmented :: Word64 -> Word64 -> CoinSelectionError

-- | When trying to construct a transaction, the max number of allowed
--   inputs was reached.
MaximumInputsReached :: Word64 -> CoinSelectionError
data CoinSelection
CoinSelection :: [(TxIn, TxOut)] -> [TxOut] -> [Coin] -> CoinSelection

-- | Picked inputs
[inputs] :: CoinSelection -> [(TxIn, TxOut)]

-- | Picked outputs
[outputs] :: CoinSelection -> [TxOut]

-- | Resulting changes
[change] :: CoinSelection -> [Coin]

-- | Shuffles a list of elements.
--   
--   <pre>
--   &gt;&gt;&gt; shuffle (outputs coinSel)
--   [...]
--   </pre>
shuffle :: [a] -> IO [a]
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.CoinSelection
instance GHC.Show.Show Cardano.Wallet.CoinSelection.CoinSelection
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.CoinSelection
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.CoinSelectionError
instance GHC.Show.Show Cardano.Wallet.CoinSelection.CoinSelectionError
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.CoinSelectionOptions
instance GHC.Base.Semigroup Cardano.Wallet.CoinSelection.CoinSelection
instance GHC.Base.Monoid Cardano.Wallet.CoinSelection.CoinSelection
instance Formatting.Buildable.Buildable Cardano.Wallet.CoinSelection.CoinSelection


-- | This module contains the implementation of largestFirst input
--   selection algorithm
module Cardano.Wallet.CoinSelection.Policy.LargestFirst

-- | Largest-first input selection policy
largestFirst :: forall m. Monad m => CoinSelectionOptions -> NonEmpty TxOut -> UTxO -> ExceptT CoinSelectionError m (CoinSelection, UTxO)


-- | This module contains the implementation of random input selection
--   algorithm
module Cardano.Wallet.CoinSelection.Policy.Random

-- | Random-Improve Algorithm
--   
--   <ol>
--   <li>Randomly select outputs from the UTxO until the payment value is
--   covered. (In the rare case that this fails because the maximum number
--   of transaction inputs has been exceeded, fall-back on the
--   largest-first algorithm for this step.)</li>
--   <li>Randomly select outputs from the UTxO, considering for each output
--   if that output is animprovement. If it is, add it to the transaction,
--   and keep going. An output is considered an improvement when:</li>
--   </ol>
--   
--   (a) It doesn’t exceed a specified upper limit. (b) Adding the new
--   output gets us closer to the ideal change value. (c) It doesn’t exceed
--   a maximum number of transaction inputs.
--   
--   This algorithm follows three principles:
--   
--   <pre>
--   **Self organisation principle 1**
--   Random selection has a high probability of picking dust outputs precisely
--   when there is a lot of dust in the UTxO.
--   </pre>
--   
--   <pre>
--   **Self organisation principle 2**
--   If for each payment request for value <tt>x</tt> we create a change output roughly
--   of the same value <tt>x</tt>, then we will end up with a lot of change outputs in
--   our UTxO of size <tt>x</tt> precisely when we have a lot of payment requests of
--   size <tt>x</tt>
--   </pre>
--   
--   <pre>
--   **Self organisation principle 3**
--   Searching the UTxO for additional entries to improve our change output is
--   only useful if the UTxO contains entries that are sufficiently small enough.
--   But precisely when the UTxO contains many small entries, it is less likely
--   that a randomly chosen UTxO entry will push the total above the upper bound
--   we set.
--   </pre>
random :: forall m. MonadRandom m => CoinSelectionOptions -> NonEmpty TxOut -> UTxO -> ExceptT CoinSelectionError m (CoinSelection, UTxO)


-- | This module contains static configuration parameters. Rather than
--   providing and carrying around a configuration file through the
--   application, we resolve configuration data at runtime using the
--   available environment.
--   
--   This gives us a flexible and portable approach to software
--   configuration, and remove some pain from the development perspective.
--   Prior to starting, the wallet is expected to have a few configuration
--   parameter available. One may rely on a `.env` file to bundle
--   configuration settings together for a given target environment.
module Cardano.Environment

-- | Available network options. <a>Local</a> means a local cluster running
--   on the host machine.
data Network
Mainnet :: Network
Testnet :: Network
Staging :: Network
Local :: Network

-- | Get the current target <a>Network</a> from the Environment.
--   
--   Throws a runtime exception is the ENV var isn't set or, is invalid.
network :: Network
newtype ProtocolMagic
ProtocolMagic :: Int32 -> ProtocolMagic

-- | Get the <a>ProtocolMagic</a> corresponding to a given <a>Network</a>.
--   
--   Note that the <a>ProtocolMagic</a> for <a>Local</a> and <a>Testnet</a>
--   are the same.
protocolMagic :: Network -> ProtocolMagic

-- | Fatal exception thrown when a required ENV var is missing upon
--   start-up.
data ErrMissingOrInvalidEnvVar
ErrMissingOrInvalidEnvVar :: String -> String -> Maybe (String, TextDecodingError) -> ErrMissingOrInvalidEnvVar
[name] :: ErrMissingOrInvalidEnvVar -> String
[command] :: ErrMissingOrInvalidEnvVar -> String
[additionalContext] :: ErrMissingOrInvalidEnvVar -> Maybe (String, TextDecodingError)

-- | Lookup the environment for a given variable
unsafeLookupEnv :: FromText a => String -> a
instance GHC.Show.Show Cardano.Environment.ProtocolMagic
instance GHC.Generics.Generic Cardano.Environment.ProtocolMagic
instance GHC.Enum.Enum Cardano.Environment.Network
instance GHC.Classes.Eq Cardano.Environment.Network
instance GHC.Show.Show Cardano.Environment.Network
instance GHC.Generics.Generic Cardano.Environment.Network
instance Data.Text.Class.FromText Cardano.Environment.Network
instance Data.Text.Class.ToText Cardano.Environment.Network
instance GHC.Show.Show Cardano.Environment.ErrMissingOrInvalidEnvVar
instance GHC.Exception.Type.Exception Cardano.Environment.ErrMissingOrInvalidEnvVar


-- | Provides the API of Coin Selection algorithm and Fee Calculation This
--   module contains the implementation of adjusting coin selection for a
--   fee. The sender pays for the fee and additional inputs are picked
--   randomly. For more information refer to:
--   <a>https://iohk.io/blog/self-organisation-in-coin-selection/</a>
module Cardano.Wallet.CoinSelection.Fee

-- | A <a>Fee</a>, isomorph to <a>Coin</a> but ease type-signatures and
--   readability.
newtype Fee
Fee :: Word64 -> Fee
[getFee] :: Fee -> Word64
data FeeOptions
FeeOptions :: (CoinSelection -> Fee) -> Coin -> FeeOptions

-- | Estimate fees based on number of inputs and values of the outputs Some
--   pointers / order of magnitude from the current configuration: a:
--   155381 # absolute minimal fees per transaction b: 43.946 # additional
--   minimal fees per byte of transaction size
[estimate] :: FeeOptions -> CoinSelection -> Fee

-- | Change addresses below the given threshold will be evicted from the
--   created transaction. Setting <a>dustThreshold</a> to 0 removes output
--   equal to 0
[dustThreshold] :: FeeOptions -> Coin
newtype FeeError

-- | UTxO exhausted during fee covering We record what amount missed to
--   cover the fee
CannotCoverFee :: Word64 -> FeeError

-- | A linear equation on the transaction size. Represents the <tt>s -&gt;
--   a + b*s</tt> function where <tt>s</tt> is the transaction size in
--   bytes, <tt>a</tt> and <tt>b</tt> are constant coefficients.
data TxSizeLinear
TxSizeLinear :: Quantity "lovelace" Double -> Quantity "lovelace/byte" Double -> TxSizeLinear

-- | Given the coin selection result from a policy run, adjust the outputs
--   for fees, potentially returning additional inputs that we need to
--   cover all fees. We lose the relationship between the transaction
--   outputs and their corresponding inputs/change outputs here. This is a
--   decision we may wish to revisit later. For now however note that since
--   
--   (a) coin selection tries to establish a particular ratio between
--   payment outputs and change outputs (currently it aims for an average
--   of 1:1)
--   
--   (b) coin selection currently only generates a single change output per
--   payment output, distributing the fee proportionally across all change
--   outputs is roughly equivalent to distributing it proportionally over
--   the payment outputs (roughly, not exactly, because the 1:1 proportion
--   is best effort only, and may in some cases be wildly different).
--   
--   Note that for (a) we don't need the ratio to be 1:1, the above
--   reasoning will remain true for any proportion 1:n. For (b) however, if
--   coin selection starts creating multiple outputs, and this number may
--   vary, then losing the connection between outputs and change outputs
--   will mean that that some outputs may pay a larger percentage of the
--   fee (depending on how many change outputs the algorithm happened to
--   choose).
adjustForFee :: MonadRandom m => FeeOptions -> UTxO -> CoinSelection -> ExceptT FeeError m CoinSelection
cardanoPolicy :: TxSizeLinear

-- | Estimate fee for a given <a>CoinSelection</a>. Fee follows a simple
--   linear equation:
--   
--   <pre>
--   f = a + sizeOf(tx) * b
--   </pre>
--   
--   where <tt>a</tt> &amp; <tt>b</tt> are values fixed by the protocol.
--   This operation is therefore heavily coupled with the binary
--   representation of a <tt>Transaction</tt>. This estimation is only a
--   best-effort here as many of the encoding values actually depends on
--   the value of parameters at runtime.
--   
--   For instance, an amount of `50` lovelace would be encoded using 2
--   bytes, whereas an amount of `1000000` would be encoded using 4 bytes.
--   In Byron, we have only one piece of unknown from the
--   <a>CoinSelection</a> and it's the value of the <tt>crc32</tt> computed
--   on the address payload, which can be 1,2,3 or 5 bytes and we therefore
--   always consider the worst-case scenario of a 5-byte crc.
--   
--   As a consequence, our estimate may be slightly bigger than the actual
--   transaction fee (up-to 4 extra bytes per change output).
--   
--   NOTE: We assume that all change outputs follow a sequential scheme and
--   therefore, have an empty address derivation payload.
estimateFee :: TxSizeLinear -> CoinSelection -> Fee
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Fee.TxSizeLinear
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Fee.TxSizeLinear
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Fee.FeeError
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Fee.FeeError
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Fee.FeeOptions


-- | These are (partial) CBOR decoders for blocks and block headers. Note
--   that we ignore most of the block's and header's content and only
--   retrieve the pieces of information relevant to us, wallet (we do
--   assume a trusted node and therefore, we needn't to care about
--   verifying signatures and blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Wallet.Binary
decodeBlock :: Decoder s Block
decodeBlockHeader :: Decoder s BlockHeader
decodeTx :: Decoder s Tx
decodeTxWitness :: Decoder s TxWitness
decodeSignedTx :: Decoder s (Tx, [TxWitness])
encodeTx :: Tx -> Encoding

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> Encoding -> Encoding
encodeTxWitness :: TxWitness -> Encoding
encodeSignedTx :: (Tx, [TxWitness]) -> Encoding
encodeProtocolMagic :: ProtocolMagic -> Encoding

-- | Compute a transaction id; assumed to be effectively injective. It
--   returns an hex-encoded 64-byte hash.
--   
--   NOTE: This is a rather expensive operation
txId :: Tx -> Hash "Tx"
data TxWitness
PublicKeyWitness :: ByteString -> Hash "signature" -> TxWitness
ScriptWitness :: ByteString -> TxWitness
RedeemWitness :: ByteString -> TxWitness

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]
toByteString :: Encoding -> ByteString


-- | Primitives for performing address derivation for some given schemes.
--   This is where most of the crypto happens in the wallet and, it is
--   quite important to ensure that the following implementation matches
--   with other wallet softwares (like Yoroi/Icarus or the cardano-cli)
module Cardano.Wallet.Primitive.AddressDerivation

-- | A cryptographic key, with phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Key 'RootK XPrv
--   let accountPubKey = Key 'AccountK XPub
--   let addressPubKey = Key 'AddressK XPub
--   </pre>
data Key (level :: Depth) key
getKey :: Key level key -> key

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   m | purpose' | cointype' | account' | change | address
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   they are left out of the sum type.
data Depth
RootK :: Depth
AccountK :: Depth
AddressK :: Depth

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
data Index (derivationType :: DerivationType) (level :: Depth)
getIndex :: Index derivationType level -> Word32

-- | Type of derivation that should be used with the given indexes.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType

-- | Extract the public key part of a private key.
publicKey :: Key level XPrv -> Key level XPub

-- | Hash a public key to some other representation.
digest :: HashAlgorithm a => Key level XPub -> Digest a
data XPub
data XPrv

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
newtype Passphrase (purpose :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase
class PassphraseMinLength (purpose :: Symbol)

-- | Minimal Length for a passphrase, for lack of better validations
passphraseMinLength :: PassphraseMinLength purpose => Proxy purpose -> Int
class PassphraseMaxLength (purpose :: Symbol)

-- | Maximum length for a passphrase
passphraseMaxLength :: PassphraseMaxLength purpose => Proxy purpose -> Int

-- | Create a passphrase from a mnemonic sentence. This class enables
--   caller to parse text list of variable length into mnemonic sentences.
--   
--   <pre>
--   &gt;&gt;&gt; fromMnemonic @'[12,15,18,21] @"generation" ["toilet", "curse", ... ]
--   Right (Passphrase &lt;ScrubbedBytes&gt;)
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class FromMnemonic (sz :: [Nat]) (purpose :: Symbol)
fromMnemonic :: FromMnemonic sz purpose => [Text] -> Either (FromMnemonicError sz) (Passphrase purpose)

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype FromMnemonicError (sz :: [Nat])
FromMnemonicError :: String -> FromMnemonicError
[getFromMnemonicError] :: FromMnemonicError -> String

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase

-- | Encrypt a <a>Passphrase</a> into a format that is suitable for storing
--   on disk
encryptPassphrase :: MonadRandom m => Passphrase purpose -> m (Hash purpose)

-- | Check whether a <a>Passphrase</a> matches with a stored <a>Hash</a>
checkPassphrase :: Passphrase purpose -> Hash purpose -> Either ErrWrongPassphrase ()

-- | Marker for the change chain. In practice, change of a transaction goes
--   onto the addresses generated on the internal chain, whereas the
--   external chain is used for addresses that are part of the
--   <tt>advertised</tt> targets of a transaction
data ChangeChain
InternalChain :: ChangeChain
ExternalChain :: ChangeChain

-- | Generate a root key from a corresponding seed
generateKeyFromSeed :: (Passphrase "seed", Passphrase "generation") -> Passphrase "encryption" -> Key  'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (Passphrase "seed", Passphrase "generation") -> Passphrase "encryption" -> Key depth XPrv

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> Key  'RootK XPrv -> Index  'Hardened  'AccountK -> Key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   It is preferred to use <a>deriveAddressPublicKey</a> whenever possible
--   to avoid having to manipulate passphrases and private keys.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> Key  'AccountK XPrv -> ChangeChain -> Index  'Soft  'AddressK -> Key  'AddressK XPrv

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: Key  'AccountK XPub -> ChangeChain -> Index  'Soft  'AddressK -> Key  'AddressK XPub

-- | Encode a public key to a (Byron / Legacy) Cardano <a>Address</a>. This
--   is mostly dubious CBOR serializations with no data attributes.
keyToAddress :: Key  'AddressK XPub -> Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ChangeChain
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ChangeChain
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.ChangeChain
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.ErrWrongPassphrase
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.FromMnemonicError sz)
instance GHC.Base.Monoid (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Base.Semigroup (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Key level key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Key level key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Key level key)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.ChangeChain
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDerivation.ChangeChain
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic rest purpose, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic (mw : rest) purpose
instance Cardano.Wallet.Primitive.AddressDerivation.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Wallet.Primitive.AddressDerivation.NatVals rest) => Cardano.Wallet.Primitive.AddressDerivation.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic '[mw] purpose
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength "encryption"
instance (Cardano.Wallet.Primitive.AddressDerivation.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength purpose) => Data.Text.Class.FromText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Cardano.Wallet.Primitive.AddressDerivation.PassphraseMinLength "encryption"
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.AddressDerivation.Passphrase purpose)
instance Crypto.Random.Types.MonadRandom ((->) (Cardano.Wallet.Primitive.AddressDerivation.Passphrase "salt"))
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Key level key)


-- | This module provides functionality for signing transactions.
--   
--   It relies on the binary CBOR format of transactions, an
--   <tt>AddressScheme</tt> for deriving address private keys, and
--   cardano-crypto for the actual signing.
module Cardano.Wallet.Primitive.Signing

-- | Construct a standard transaction
--   
--   " Standard " here refers to the fact that we do not deal with
--   redemption, multisignature transactions, etc.
mkStdTx :: (Address -> Maybe (Key  'AddressK XPrv, Passphrase "encryption")) -> [(TxIn, TxOut)] -> [TxOut] -> Either SignTxError (Tx, [TxWitness])

-- | Possible signing error
newtype SignTxError

-- | We tried to sign a transaction with inputs that are unknown to us?
KeyNotFoundForAddress :: Address -> SignTxError
instance GHC.Show.Show Cardano.Wallet.Primitive.Signing.SignTxError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Signing.SignTxError


-- | This module contains primitives necessary to perform address
--   discovery. So far, we're only interested in address following a
--   sequential derivation scheme as specified in BIP-0044. Later, we may
--   introduce backward compatibility with random address scheme from the
--   legacy Cardano wallets.
module Cardano.Wallet.Primitive.AddressDiscovery

-- | This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   
--   <ul>
--   <li>A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address
--   scheme.</li>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s
isOurs :: IsOurs s => Address -> s -> (Bool, s)

-- | More powerful than <a>isOurs</a>, this abstractions offer the
--   underlying state the ability to find / compute the address private key
--   corresponding to a given known address.
--   
--   Requiring <a>IsOwned</a> as a constraint supposed that there is a way
--   to recover the root private key of a particular wallet. This isn't
--   true for externally owned wallet which would delegate its key
--   management to a third party (like a hardware Ledger or Trezor).
class IsOurs s => IsOwned s
isOwned :: IsOwned s => s -> (Key  'RootK XPrv, Passphrase "encryption") -> Address -> Maybe (Key  'AddressK XPrv, Passphrase "encryption")

-- | Abstracting over change address generation. In theory, this is only
--   needed for sending transactions on a wallet following a particular
--   scheme. This abstractions allows for defining an heuristic to pick new
--   change address. For instance, in BIP-44, change addresses belong to a
--   particular change chain (also called "Internal Chain").
class GenChange s
genChange :: GenChange s => s -> (Address, s)

-- | Maximum number of consecutive undiscovered addresses allowed
data AddressPoolGap

-- | Possible errors when casting to an <a>AddressPoolGap</a>
newtype MkAddressPoolGapError
ErrGapOutOfRange :: Word8 -> MkAddressPoolGapError

-- | A default <a>AddressPoolGap</a>, as suggested in BIP-0044
defaultAddressPoolGap :: AddressPoolGap
getAddressPoolGap :: AddressPoolGap -> Word8

-- | Smart constructor for <a>AddressPoolGap</a>
mkAddressPoolGap :: Word8 -> Either MkAddressPoolGapError AddressPoolGap

-- | An <a>AddressPool</a> which keeps track of sequential addresses within
--   a given Account and change chain. See <a>mkAddressPool</a> to create a
--   new or existing pool:
--   
--   <pre>
--   &gt;&gt;&gt; mkAddressPool xpub gap changeChain mempty
--   AddressPool { }
--   </pre>
data AddressPool (chain :: ChangeChain)

-- | The actual gap for the pool. This can't change for a given pool.
gap :: AddressPool chain -> AddressPoolGap

-- | Get all addresses in the pool, sorted from the first address
--   discovered, up until the next one.
--   
--   In practice, we always have:
--   
--   <pre>
--   mkAddressPool key g cc (addresses pool) == pool
--   </pre>
addresses :: AddressPool chain -> [Address]

-- | Bring a <a>ChangeChain</a> type back to the term-level. This requires
--   a type application and either a scoped type variable, or an explicit
--   passing of a <a>ChangeChain</a>.
--   
--   <pre>
--   &gt;&gt;&gt; changeChain @'ExternalChain
--   ExternalChain
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; changeChain @chain
--   ...
--   </pre>
changeChain :: forall (chain :: ChangeChain). Typeable chain => ChangeChain

-- | Corresponding key for the pool (a pool is tied to only one account)
accountPubKey :: AddressPool chain -> Key  'AccountK XPub

-- | Create a new Address pool from a list of addresses. Note that, the
--   list is expected to be ordered in sequence (first indexes, first in
--   the list).
--   
--   The pool will grow from the start if less than <tt>g ::
--   AddressPoolGap</tt> are given, such that, there are always <tt>g</tt>
--   undiscovered addresses in the pool.
mkAddressPool :: forall chain. Typeable chain => Key  'AccountK XPub -> AddressPoolGap -> [Address] -> AddressPool chain

-- | Lookup an address in the pool. When we find an address in a pool, the
--   pool may be amended if the address was discovered near the edge. It is
--   also possible that the pool is not amended at all - this happens in
--   the case that an address is discovered <tt>far</tt> from the edge.
lookupAddress :: Typeable chain => Address -> AddressPool chain -> (Maybe (Index  'Soft  'AddressK), AddressPool chain)

-- | An ordered set of pending indexes. This keep track of indexes used
data PendingIxs

-- | An empty pending set of change indexes.
--   
--   NOTE: We do not define a <a>Monoid</a> instance here because there's
--   no rational of combining two pending sets.
emptyPendingIxs :: PendingIxs
data SeqState
SeqState :: !AddressPool  'InternalChain -> !AddressPool  'ExternalChain -> !PendingIxs -> SeqState

-- | Addresses living on the <a>InternalChain</a>
[internalPool] :: SeqState -> !AddressPool  'InternalChain

-- | Addresses living on the <a>ExternalChain</a>
[externalPool] :: SeqState -> !AddressPool  'ExternalChain

-- | Indexes from the internal pool that have been used in pending
--   transactions. The list is maintained sorted in descending order (cf:
--   <a>PendingIxs</a>)
[pendingChangeIxs] :: SeqState -> !PendingIxs

-- | Construct a Sequential state for a wallet.
mkSeqState :: (Key  'RootK XPrv, Passphrase "encryption") -> AddressPoolGap -> SeqState
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.AddressPool chain)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.AddressPool chain)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.AddressPool chain)
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.MkAddressPoolGapError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.MkAddressPoolGapError
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance Cardano.Wallet.Primitive.AddressDiscovery.GenChange Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOwned Cardano.Wallet.Primitive.AddressDiscovery.SeqState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.AddressPool chain)
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap


-- | Here we find the "business logic" to manage a Cardano wallet. This is
--   a direct implementation of the model from the <a>Formal Specification
--   for a Cardano Wallet</a> Note that, this module is purposedly agnostic
--   to how blocks are retrieved or how various types are serialized.
--   
--   This is really about how the wallet keep track of its internal state,
--   and its UTxO (where the relationship is defined via the <a>IsOurs</a>
--   abstraction to allow this core code to be used with any sort of
--   derivation scheme).
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here :)
module Cardano.Wallet.Primitive.Model

-- | An opaque wallet type, see <tt>initWallet</tt> and <tt>applyBlock</tt>
--   to construct and update wallets.
--   
--   Internally, this keeps track or a few things including:
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Pending transaction</li>
--   <li>Transaction history</li>
--   <li>TODO: Known &amp; used addresses</li>
--   </ul>
data Wallet s

-- | Create an empty wallet from an initial state
initWallet :: (IsOurs s, NFData s, Show s) => s -> Wallet s

-- | Update the state of an existing Wallet model
updateState :: (IsOurs s, NFData s, Show s) => s -> Wallet s -> Wallet s

-- | Apply Block is the only way to make the wallet evolve. It returns a
--   new updated wallet state, as well as the set of all our transaction
--   discovered while applying the block.
applyBlock :: Block -> Wallet s -> (Map (Hash "Tx") (Tx, TxMeta), Wallet s)

-- | Helper to apply multiple blocks in sequence to an existing wallet.
--   It's basically just a <tt>foldl' applyBlock</tt> over the given
--   blocks.
applyBlocks :: [Block] -> Wallet s -> (Map (Hash "Tx") (Tx, TxMeta), Wallet s)
newPending :: Tx -> Wallet s -> Wallet s

-- | Get the wallet current tip
currentTip :: Wallet s -> SlotId

-- | Get the wallet current state
getState :: Wallet s -> s

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: Wallet s -> Natural

-- | Total balance = <a>balance</a> . <a>totalUTxO</a>
totalBalance :: Wallet s -> Natural

-- | Total UTxO = <a>availableUTxO</a> <tt>&lt;&gt;</tt> <a>changeUTxO</a>
totalUTxO :: Wallet s -> UTxO

-- | Available UTxO = <tt>pending ⋪ utxo</tt>
availableUTxO :: Wallet s -> UTxO
instance GHC.Show.Show (Cardano.Wallet.Primitive.Model.Wallet s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Cardano.Wallet.Primitive.Model.Wallet s)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Model.Wallet s)


-- | Database / Pesistence layer for the wallet backend. This is where we
--   define the interface allowing us to store and fetch various data on
--   our wallets.
module Cardano.Wallet.DB

-- | A Database interface for storing various things in a DB. In practice,
--   we'll need some extra contraints on the wallet state that allows us to
--   serialize and unserialize it (e.g. <tt>forall s. (Serialize s) =&gt;
--   ...</tt>)
data DBLayer m s
DBLayer :: (PrimaryKey WalletId -> Wallet s -> WalletMetadata -> ExceptT ErrWalletAlreadyExists m ()) -> (PrimaryKey WalletId -> ExceptT ErrNoSuchWallet m ()) -> m [PrimaryKey WalletId] -> (PrimaryKey WalletId -> Wallet s -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe (Wallet s))) -> (PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe WalletMetadata)) -> (PrimaryKey WalletId -> Map (Hash "Tx") (Tx, TxMeta) -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Map (Hash "Tx") (Tx, TxMeta))) -> (PrimaryKey WalletId -> (Key  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet m ()) -> (PrimaryKey WalletId -> m (Maybe (Key  'RootK XPrv, Hash "encryption"))) -> (forall e a. () => ExceptT e m a -> ExceptT e m a) -> DBLayer m s

-- | Initialize a database entry for a given wallet. <a>putCheckpoint</a>,
--   <a>putWalletMeta</a> or <a>putTxHistory</a> will actually all fail if
--   they are called _first_ on a wallet.
[createWallet] :: DBLayer m s -> PrimaryKey WalletId -> Wallet s -> WalletMetadata -> ExceptT ErrWalletAlreadyExists m ()

-- | Remove a given wallet and all its associated data (checkpoints,
--   metadata, tx history ...)
[removeWallet] :: DBLayer m s -> PrimaryKey WalletId -> ExceptT ErrNoSuchWallet m ()

-- | Get the list of all known wallets in the DB, possibly empty.
[listWallets] :: DBLayer m s -> m [PrimaryKey WalletId]

-- | Replace the current checkpoint for a given wallet. We do not handle
--   rollbacks yet, and therefore only stores the latest available
--   checkpoint.
--   
--   If the wallet doesn't exist, this operation returns an error.
[putCheckpoint] :: DBLayer m s -> PrimaryKey WalletId -> Wallet s -> ExceptT ErrNoSuchWallet m ()

-- | Fetch the most recent checkpoint of a given wallet.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readCheckpoint] :: DBLayer m s -> PrimaryKey WalletId -> m (Maybe (Wallet s))

-- | Replace an existing wallet metadata with the given one.
--   
--   If the wallet doesn't exist, this operation returns an error
[putWalletMeta] :: DBLayer m s -> PrimaryKey WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet m ()

-- | Fetch a wallet metadata, if they exist.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readWalletMeta] :: DBLayer m s -> PrimaryKey WalletId -> m (Maybe WalletMetadata)

-- | Augments the transaction history for a known wallet.
--   
--   If an entry for a particular transaction already exists it is not
--   altered nor merged (just ignored).
--   
--   If the wallet doesn't exist, this operation returns an error.
[putTxHistory] :: DBLayer m s -> PrimaryKey WalletId -> Map (Hash "Tx") (Tx, TxMeta) -> ExceptT ErrNoSuchWallet m ()

-- | Fetch the current transaction history of a known wallet.
--   
--   Returns an empty map if the wallet isn't found.
[readTxHistory] :: DBLayer m s -> PrimaryKey WalletId -> m (Map (Hash "Tx") (Tx, TxMeta))

-- | Store or replace a private key for a given wallet. Note that wallet
--   _could_ be stored and manipulated without any private key associated
--   to it. A private key is only seldomly required for very specific
--   operations (like transaction signing).
[putPrivateKey] :: DBLayer m s -> PrimaryKey WalletId -> (Key  'RootK XPrv, Hash "encryption") -> ExceptT ErrNoSuchWallet m ()

-- | Read a previously stored private key and its associated passphrase
--   hash.
[readPrivateKey] :: DBLayer m s -> PrimaryKey WalletId -> m (Maybe (Key  'RootK XPrv, Hash "encryption"))
[withLock] :: DBLayer m s -> forall e a. () => ExceptT e m a -> ExceptT e m a

-- | A primary key which can take many forms depending on the value. This
--   may become a type family as we move forward, but for now, it
--   illustrate that some queries are ran against some sort of store;
--   
--   As a matter of fact, we may manipulate multiple wallets at the same
--   time, so, functions like <tt>enqueueCheckpoint</tt> needs to be
--   associated to a corresponding wallet. Some other may not because they
--   are information valid for all wallets (like for instance, the last
--   known network tip).
newtype PrimaryKey key
PrimaryKey :: key -> PrimaryKey key

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists
instance GHC.Classes.Ord key => GHC.Classes.Ord (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.DB.PrimaryKey key)
instance GHC.Show.Show Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Show.Show Cardano.Wallet.DB.ErrNoSuchWallet
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrNoSuchWallet


-- | Dummy implementation of the database-layer, using MVar. This may be
--   good for state-machine testing in order to compare it with an
--   implementation on a real data store.
module Cardano.Wallet.DB.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: forall s. IO (DBLayer IO s)


-- | API type representations of various types. We define here pretty much
--   all our user-facing types that are mostly composed with internal /
--   primitive types.
--   
--   This module also define required API instances (JSON, HttpApiData...)
--   for all those types, making sure to match the specification document:
--   
--   <a>Wallet API Specification</a>
module Cardano.Wallet.Api.Types
data ApiAddress
ApiAddress :: !ApiT Address -> !ApiT AddressState -> ApiAddress
[$sel:id:ApiAddress] :: ApiAddress -> !ApiT Address
[$sel:state:ApiAddress] :: ApiAddress -> !ApiT AddressState
data ApiWallet
ApiWallet :: !ApiT WalletId -> !ApiT AddressPoolGap -> !ApiT WalletBalance -> !ApiT (WalletDelegation (ApiT PoolId)) -> !ApiT WalletName -> !ApiT WalletPassphraseInfo -> !ApiT WalletState -> ApiWallet
[$sel:id:ApiWallet] :: ApiWallet -> !ApiT WalletId
[$sel:addressPoolGap:ApiWallet] :: ApiWallet -> !ApiT AddressPoolGap
[$sel:balance:ApiWallet] :: ApiWallet -> !ApiT WalletBalance
[$sel:delegation:ApiWallet] :: ApiWallet -> !ApiT (WalletDelegation (ApiT PoolId))
[$sel:name:ApiWallet] :: ApiWallet -> !ApiT WalletName
[$sel:passphrase:ApiWallet] :: ApiWallet -> !ApiT WalletPassphraseInfo
[$sel:state:ApiWallet] :: ApiWallet -> !ApiT WalletState
data WalletBalance
WalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> WalletBalance
[$sel:available:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
[$sel:total:WalletBalance] :: WalletBalance -> !Quantity "lovelace" Natural
data WalletPostData
WalletPostData :: !Maybe (ApiT AddressPoolGap) -> !ApiMnemonicT '[15, 18, 21, 24] "seed" -> !Maybe (ApiMnemonicT '[9, 12] "generation") -> !ApiT WalletName -> !ApiT (Passphrase "encryption") -> WalletPostData
[$sel:addressPoolGap:WalletPostData] :: WalletPostData -> !Maybe (ApiT AddressPoolGap)
[$sel:mnemonicSentence:WalletPostData] :: WalletPostData -> !ApiMnemonicT '[15, 18, 21, 24] "seed"
[$sel:mnemonicSecondFactor:WalletPostData] :: WalletPostData -> !Maybe (ApiMnemonicT '[9, 12] "generation")
[$sel:name:WalletPostData] :: WalletPostData -> !ApiT WalletName
[$sel:passphrase:WalletPostData] :: WalletPostData -> !ApiT (Passphrase "encryption")
newtype WalletPutData
WalletPutData :: Maybe (ApiT WalletName) -> WalletPutData
[$sel:name:WalletPutData] :: WalletPutData -> Maybe (ApiT WalletName)
data WalletPutPassphraseData
WalletPutPassphraseData :: !ApiT (Passphrase "encryption") -> !ApiT (Passphrase "encryption") -> WalletPutPassphraseData
[$sel:oldPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption")
[$sel:newPassphrase:WalletPutPassphraseData] :: WalletPutPassphraseData -> !ApiT (Passphrase "encryption")
data PostTransactionData
PostTransactionData :: !NonEmpty ApiCoins -> !ApiT (Passphrase "encryption") -> PostTransactionData
[$sel:targets:PostTransactionData] :: PostTransactionData -> !NonEmpty ApiCoins
[$sel:passphrase:PostTransactionData] :: PostTransactionData -> !ApiT (Passphrase "encryption")
data ApiBlockData
ApiBlockData :: UTCTime -> !ApiT SlotId -> ApiBlockData
[$sel:time:ApiBlockData] :: ApiBlockData -> UTCTime
[$sel:block:ApiBlockData] :: ApiBlockData -> !ApiT SlotId
data ApiTransaction
ApiTransaction :: !ApiT (Hash "Tx") -> !Quantity "lovelace" Natural -> !Maybe ApiBlockData -> !Quantity "block" Natural -> !ApiT Direction -> !NonEmpty ApiCoins -> !NonEmpty ApiCoins -> !ApiT TxStatus -> ApiTransaction
[$sel:id:ApiTransaction] :: ApiTransaction -> !ApiT (Hash "Tx")
[$sel:amount:ApiTransaction] :: ApiTransaction -> !Quantity "lovelace" Natural
[$sel:insertedAt:ApiTransaction] :: ApiTransaction -> !Maybe ApiBlockData
[$sel:depth:ApiTransaction] :: ApiTransaction -> !Quantity "block" Natural
[$sel:direction:ApiTransaction] :: ApiTransaction -> !ApiT Direction
[$sel:inputs:ApiTransaction] :: ApiTransaction -> !NonEmpty ApiCoins
[$sel:outputs:ApiTransaction] :: ApiTransaction -> !NonEmpty ApiCoins
[$sel:status:ApiTransaction] :: ApiTransaction -> !ApiT TxStatus
data ApiCoins
ApiCoins :: !ApiT Address -> !Quantity "lovelace" Natural -> ApiCoins
[$sel:address:ApiCoins] :: ApiCoins -> !ApiT Address
[$sel:amount:ApiCoins] :: ApiCoins -> !Quantity "lovelace" Natural

-- | Polymorphic wrapper type to put around primitive types and, 3rd party
--   lib types to avoid defining orphan instances and/or, undesirable
--   instances on primitive types. It helps to keep a nice separation of
--   concerns between the API layer and other modules.
newtype ApiT a
ApiT :: a -> ApiT a
[$sel:getApiT:ApiT] :: ApiT a -> a

-- | Representation of mnemonics at the API-level, using a polymorphic type
--   in the lengths of mnemonics that are supported (and an underlying
--   purpose). In practice, mnemonics correspond to passphrases or seeds,
--   and although they're nice to manipulate as mnemonics from a
--   user-perspective, carrying around a list of words doesn't really make
--   sense for the business logic, which prefers manipulating scrubbed
--   bytes directly.
--   
--   <pre>
--   data MyWallet
--       { mnemonic :: ApiMnemonicT '[15,18,21,24] "root-seed"
--       }
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
--   
--   Also, the internal representation holds a <tt>[Text]</tt> which
--   contains the list of mnemonic words that was parsed. This is only to
--   be able to implement the <a>ToJSON</a> instances and roundtrip, which
--   is a very dubious argument. In practice, we'll NEVER peek at the
--   mnemonic, output them and whatnot.
newtype ApiMnemonicT (sizes :: [Nat]) (purpose :: Symbol)
ApiMnemonicT :: (Passphrase purpose, [Text]) -> ApiMnemonicT
getApiMnemonicT :: ApiMnemonicT sizes purpose -> Passphrase purpose
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAddress
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAddress
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAddress
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Show.Show Cardano.Wallet.Api.Types.PostTransactionData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.PostTransactionData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.PostTransactionData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTransaction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTransaction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTransaction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiCoins
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiCoins
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiCoins
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBlockData
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPostData
instance Cardano.Wallet.Primitive.AddressDerivation.FromMnemonic sizes purpose => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes purpose)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAddress
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAddress
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.PostTransactionData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.PostTransactionData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTransaction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTransaction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiCoins
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiCoins
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBlockData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBlockData
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.AddressState)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase "encryption"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Passphrase "encryption"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.AddressPoolGap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletBalance)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.WalletDelegation (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.WalletDelegation (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletPassphraseInfo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletState)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash "Tx"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Direction)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TxStatus)
instance Data.Text.Class.FromText a => Web.Internal.HttpApiData.FromHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Text.Class.ToText a => Web.Internal.HttpApiData.ToHttpApiData (Cardano.Wallet.Api.Types.ApiT a)


-- | Provides the wallet layer functions that are used by API layer and
--   uses both <a>Cardano.Wallet.DB</a> and <a>Cardano.Wallet.Network</a>
--   to realize its role as being intermediary between the three.
module Cardano.Wallet
data WalletLayer s
WalletLayer :: (WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists IO WalletId) -> (WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s, WalletMetadata)) -> IO [WalletId] -> (WalletId -> ExceptT ErrNoSuchWallet IO ()) -> (WalletId -> ExceptT ErrNoSuchWallet IO ()) -> (WalletId -> CoinSelectionOptions -> NonEmpty TxOut -> ExceptT ErrCreateUnsignedTx IO CoinSelection) -> (WalletId -> Passphrase "encryption" -> CoinSelection -> ExceptT ErrSignTx IO (Tx, TxMeta, [TxWitness])) -> (WalletId -> (Tx, TxMeta, [TxWitness]) -> ExceptT ErrSubmitTx IO ()) -> (WalletId -> (Key  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrNoSuchWallet IO ()) -> WalletLayer s

-- | Initialise and store a new wallet, returning its Id.
[$sel:createWallet:WalletLayer] :: WalletLayer s -> WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists IO WalletId

-- | Retrieve the wallet state for the wallet with the given ID.
[$sel:readWallet:WalletLayer] :: WalletLayer s -> WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s, WalletMetadata)

-- | Retrieve a list of known wallets IDs.
[$sel:listWallets:WalletLayer] :: WalletLayer s -> IO [WalletId]

-- | Remove an existing wallet. Note that, there's no particular work to be
--   done regarding the restoration worker as it will simply terminate on
--   the next tick when noticing that the corresponding wallet is gone.
[$sel:removeWallet:WalletLayer] :: WalletLayer s -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Restore a wallet from its current tip up to a given target (typically,
--   the network tip).
--   
--   It returns immediately and fail if the wallet is already beyond the
--   given tip. It starts a worker in background which will fetch and apply
--   remaining blocks until failure or, the target slot is reached.
[$sel:restoreWallet:WalletLayer] :: WalletLayer s -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Prepare a transaction and automatically select inputs from the wallet
--   to cover the requested outputs. Note that this only run the coin
--   selection for the given outputs. In order to construct (and sign) an
--   actual transaction, have a look at <a>$sel:signTx:WalletLayer</a>.
[$sel:createUnsignedTx:WalletLayer] :: WalletLayer s -> WalletId -> CoinSelectionOptions -> NonEmpty TxOut -> ExceptT ErrCreateUnsignedTx IO CoinSelection

-- | Produce witnesses and construct a transaction from a given selection.
--   Requires the encryption passphrase in order to decrypt the root
--   private key. Note that this doesn't broadcast the transaction to the
--   network. In order to do so, have a look at
--   <a>$sel:submitTx:WalletLayer</a>.
[$sel:signTx:WalletLayer] :: WalletLayer s -> WalletId -> Passphrase "encryption" -> CoinSelection -> ExceptT ErrSignTx IO (Tx, TxMeta, [TxWitness])

-- | Broadcast a (signed) transaction to the network.
[$sel:submitTx:WalletLayer] :: WalletLayer s -> WalletId -> (Tx, TxMeta, [TxWitness]) -> ExceptT ErrSubmitTx IO ()

-- | Attach a given private key to a wallet. The private key is necessary
--   for some operations like signing transactions or, generating new
--   accounts.
[$sel:attachPrivateKey:WalletLayer] :: WalletLayer s -> WalletId -> (Key  'RootK XPrv, Passphrase "encryption") -> ExceptT ErrNoSuchWallet IO ()

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists

-- | Errors occuring when signing a transaction
data ErrSignTx
ErrSignTx :: SignTxError -> ErrSignTx
ErrSignTxNoSuchWallet :: ErrNoSuchWallet -> ErrSignTx
ErrSignTxWrongPassphrase :: ErrWrongPassphrase -> ErrSignTx

-- | Errors occuring when submitting a signed transaction to the network
data ErrSubmitTx
ErrSubmitTxNetwork :: ErrPostTx -> ErrSubmitTx
ErrSubmitTxNoSuchWallet :: ErrNoSuchWallet -> ErrSubmitTx

-- | Errors occuring when creating an unsigned transaction
data ErrCreateUnsignedTx
ErrCreateUnsignedTxNoSuchWallet :: ErrNoSuchWallet -> ErrCreateUnsignedTx
ErrCreateUnsignedTxCoinSelection :: CoinSelectionError -> ErrCreateUnsignedTx
ErrCreateUnsignedTxFee :: FeeError -> ErrCreateUnsignedTx

-- | Create a new instance of the wallet layer.
mkWalletLayer :: forall s. (IsOwned s, GenChange s, NFData s, Show s) => DBLayer IO s -> NetworkLayer IO -> WalletLayer s

-- | Run an ExcepT and throws the error if any. This makes sense only if
--   called after checking for an invariant or, after ensuring that
--   preconditions for meeting the underlying error have been discarded.
unsafeRunExceptT :: (MonadFail m, Show e) => ExceptT e m a -> m a


-- | Extra content types for Servant.
module Servant.Extra.ContentTypes

-- | Represents a piece of binary data for which a hash value should be
--   calculated before performing any further deserialization.
data ComputeHash algorithm a

-- | Represents a CBOR (Concise Binary Object Representation) object.
--   
--   See RFC 7049 (http:/<i>cbor.io</i>) for further details.
data CBOR

-- | The class of types that can be converted to from CBOR.
class FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a

-- | Represents the result of hashing a piece of data.
newtype Hash algorithm a
Hash :: Digest algorithm -> Hash algorithm a

-- | Represents something that has been packed with the Cardano packfile
--   format.
data Packed a

-- | Represents a piece of data with an accompanying hash value.
data WithHash algorithm a
WithHash :: Digest algorithm -> a -> WithHash algorithm a
[getHash] :: WithHash algorithm a -> Digest algorithm
[getValue] :: WithHash algorithm a -> a

-- | Any media type
data Any
instance GHC.Show.Show a => GHC.Show.Show (Servant.Extra.ContentTypes.WithHash algorithm a)
instance Servant.API.ContentTypes.Accept Servant.Extra.ContentTypes.Any
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.Packed a)
instance Servant.API.ContentTypes.MimeUnrender a b => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.Packed a) [b]
instance (Servant.API.ContentTypes.MimeUnrender a b, Crypto.Hash.Types.HashAlgorithm alg) => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.ComputeHash alg a) (Servant.Extra.ContentTypes.WithHash alg b)
instance Web.Internal.HttpApiData.ToHttpApiData (Servant.Extra.ContentTypes.Hash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.ComputeHash algorithm a)
instance Servant.Extra.ContentTypes.FromCBOR a => Servant.API.ContentTypes.MimeUnrender Servant.Extra.ContentTypes.CBOR a
instance Servant.API.ContentTypes.Accept Servant.Extra.ContentTypes.CBOR


-- | An API specification for the Cardano HTTP Bridge.
module Cardano.Wallet.Network.HttpBridge.Api
type Api = GetBlockByHash :<|> GetEpochById :<|> GetTipBlockHeader :<|> PostSignedTx
api :: Proxy Api
newtype ApiT a
ApiT :: a -> ApiT a
[getApiT] :: ApiT a -> a

-- | Represents a unique epoch.
newtype EpochIndex
EpochIndex :: Word64 -> EpochIndex
[getEpochIndex] :: EpochIndex -> Word64

-- | Represents the name of a Cardano network.
newtype NetworkName
NetworkName :: Text -> NetworkName
[getNetworkName] :: NetworkName -> Text
instance GHC.Show.Show Cardano.Wallet.Network.HttpBridge.Api.NetworkName
instance GHC.Classes.Eq Cardano.Wallet.Network.HttpBridge.Api.NetworkName
instance GHC.Show.Show Cardano.Wallet.Network.HttpBridge.Api.EpochIndex
instance GHC.Classes.Eq Cardano.Wallet.Network.HttpBridge.Api.EpochIndex
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Network.HttpBridge.Api.ApiT a)
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Network.HttpBridge.Api.NetworkName
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Network.HttpBridge.Api.EpochIndex
instance Servant.Extra.ContentTypes.FromCBOR (Cardano.Wallet.Network.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.Types.Block)
instance Servant.Extra.ContentTypes.FromCBOR (Cardano.Wallet.Network.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.Types.BlockHeader)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Network.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.Types.SignedTx)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Network.HttpBridge.Api.ApiT Cardano.Wallet.Primitive.Types.SignedTx)


-- | This module contains the necessary logic to talk to implement the
--   network layer using the cardano-http-bridge as a chain producer.
module Cardano.Wallet.Network.HttpBridge

-- | Endpoints of the cardano-http-bridge API.
data HttpBridge m
HttpBridge :: (Hash "BlockHeader" -> ExceptT ErrNetworkUnreachable m Block) -> (Word64 -> ExceptT ErrNetworkUnreachable m [Block]) -> ExceptT ErrNetworkTip m (Hash "BlockHeader", BlockHeader) -> (SignedTx -> ExceptT ErrPostTx m ()) -> HttpBridge m
[$sel:getBlock:HttpBridge] :: HttpBridge m -> Hash "BlockHeader" -> ExceptT ErrNetworkUnreachable m Block
[$sel:getEpoch:HttpBridge] :: HttpBridge m -> Word64 -> ExceptT ErrNetworkUnreachable m [Block]
[$sel:getNetworkTip:HttpBridge] :: HttpBridge m -> ExceptT ErrNetworkTip m (Hash "BlockHeader", BlockHeader)
[$sel:postSignedTx:HttpBridge] :: HttpBridge m -> SignedTx -> ExceptT ErrPostTx m ()

-- | Constructs a network layer with the given cardano-http-bridge API.
mkNetworkLayer :: Monad m => HttpBridge m -> NetworkLayer m

-- | Creates a cardano-http-bridge <a>NetworkLayer</a> using the given
--   connection settings.
newNetworkLayer :: Int -> IO (NetworkLayer IO)

-- | Construct a new network layer
mkHttpBridge :: Manager -> BaseUrl -> NetworkName -> HttpBridge IO

module Cardano.Wallet.Api
type Api = Addresses :<|> Wallets :<|> Transactions
type Addresses = ListAddresses

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listAddresses</a>
type ListAddresses = "wallets" :> Capture "walletId" (ApiT WalletId) :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddress]
type Wallets = DeleteWallet :<|> GetWallet :<|> ListWallets :<|> PostWallet :<|> PutWallet :<|> PutWalletPassphrase

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteWallet</a>
type DeleteWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent '[Any] NoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWallet</a>
type GetWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listWallets</a>
type ListWallets = "wallets" :> Get '[JSON] [ApiWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postWallet</a>
type PostWallet = "wallets" :> ReqBody '[JSON] WalletPostData :> PostAccepted '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWallet</a>
type PutWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] WalletPutData :> Put '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWalletPassphrase</a>
type PutWalletPassphrase = "wallets" :> Capture "walletId" (ApiT WalletId) :> "passphrase" :> ReqBody '[JSON] WalletPutPassphraseData :> Put '[Any] NoContent
type Transactions = CreateTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransaction</a>
type CreateTransaction = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] PostTransactionData :> PostAccepted '[JSON] ApiTransaction


-- | API handlers and server using the underlying wallet layer to provide
--   endpoints reachable through HTTP.
module Cardano.Wallet.Api.Server

-- | A Servant server for our wallet API
server :: WalletLayer SeqState -> Server Api
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrNoSuchWallet
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.DB.ErrWalletAlreadyExists
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrCreateUnsignedTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSignTx
instance Cardano.Wallet.Api.Server.LiftHandler Cardano.Wallet.ErrSubmitTx
